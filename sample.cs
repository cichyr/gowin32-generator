// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//	   This serves to be a form of example on how it is done by CsWin32.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using global::System.Runtime.Versioning;
using winmdroot = global::Windows.Win32;
[assembly: global::System.Reflection.AssemblyMetadata("Microsoft.Windows.CsWin32","0.3.49-beta+91f5c15987")]
namespace Windows.Win32
{

	/// <content>
	/// Contains extern methods from "KERNEL32.dll".
	/// </content>
	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
	internal static partial class PInvoke
	{
		/// <summary>Closes an open object handle.</summary>
		/// <param name="hObject">A valid handle to an open object.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[SupportedOSPlatform("windows5.0")]
		internal static winmdroot.Foundation.BOOL CloseHandle(winmdroot.Foundation.HANDLE hObject)
		{
			Marshal.SetLastSystemError(0);
			winmdroot.Foundation.BOOL __retVal = LocalExternFunction(hObject);
			Marshal.SetLastPInvokeError(Marshal.GetLastSystemError());
			return __retVal;

			[DllImport("KERNEL32.dll", ExactSpelling = true, EntryPoint = "CloseHandle")]
			static extern winmdroot.Foundation.BOOL LocalExternFunction(winmdroot.Foundation.HANDLE hObject);
		}

		/// <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
		/// <param name="hLibModule">
		/// <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
		/// </returns>
		/// <remarks>
		/// <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>. The reference count is also incremented by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time the <b>FreeLibrary</b> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call <b>FreeLibrary</b> from <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. Calling <b>FreeLibrary</b> does not affect other processes that are using the same module. Use caution when calling <b>FreeLibrary</b> with a handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[SupportedOSPlatform("windows5.1.2600")]
		internal static winmdroot.Foundation.BOOL FreeLibrary(winmdroot.Foundation.HMODULE hLibModule)
		{
			Marshal.SetLastSystemError(0);
			winmdroot.Foundation.BOOL __retVal = LocalExternFunction(hLibModule);
			Marshal.SetLastPInvokeError(Marshal.GetLastSystemError());
			return __retVal;

			[DllImport("KERNEL32.dll", ExactSpelling = true, EntryPoint = "FreeLibrary")]
			static extern winmdroot.Foundation.BOOL LocalExternFunction(winmdroot.Foundation.HMODULE hLibModule);
		}
	}


	/// <content>
	/// Contains extern methods from "USER32.dll".
	/// </content>
	internal static partial class PInvoke
	{
		/// <summary>Destroys an icon and frees any memory the icon occupied.</summary>
		/// <param name="hIcon">
		/// <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[SupportedOSPlatform("windows5.0")]
		internal static winmdroot.Foundation.BOOL DestroyIcon(winmdroot.UI.WindowsAndMessaging.HICON hIcon)
		{
			Marshal.SetLastSystemError(0);
			winmdroot.Foundation.BOOL __retVal = LocalExternFunction(hIcon);
			Marshal.SetLastPInvokeError(Marshal.GetLastSystemError());
			return __retVal;

			[DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "DestroyIcon")]
			static extern winmdroot.Foundation.BOOL LocalExternFunction(winmdroot.UI.WindowsAndMessaging.HICON hIcon);
		}

		/// <inheritdoc cref="GetCursorPos(global::System.Drawing.Point*)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.BOOL GetCursorPos(out global::System.Drawing.Point lpPoint)
		{
			fixed (global::System.Drawing.Point* lpPointLocal = &lpPoint)
			{
				winmdroot.Foundation.BOOL __result = PInvoke.GetCursorPos(lpPointLocal);
				return __result;
			}
		}

		/// <summary>Retrieves the position of the mouse cursor, in screen coordinates.</summary>
		/// <param name="lpPoint">
		/// <para>Type: <b>LPPOINT</b> A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that receives the screen coordinates of the cursor.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcursorpos#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>BOOL</b> Returns nonzero if successful or zero otherwise. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains the cursor. The calling process must have <b>WINSTA_READATTRIBUTES</b> access to the window station. The input desktop must be the current desktop when you call <b>GetCursorPos</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openinputdesktop">OpenInputDesktop</a> to determine whether the current desktop is the input desktop. If it is not, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setthreaddesktop">SetThreadDesktop</a> with the <b>HDESK</b> returned by <b>OpenInputDesktop</b> to switch to that desktop.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcursorpos#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.BOOL GetCursorPos(global::System.Drawing.Point* lpPoint)
		{
			Marshal.SetLastSystemError(0);
			winmdroot.Foundation.BOOL __retVal = LocalExternFunction(lpPoint);
			Marshal.SetLastPInvokeError(Marshal.GetLastSystemError());
			return __retVal;

			[DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "GetCursorPos")]
			static extern unsafe winmdroot.Foundation.BOOL LocalExternFunction(global::System.Drawing.Point* lpPoint);
		}

		/// <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
		/// <param name="hCursor">
		/// <para>Type: <b>HCURSOR</b> A handle to the cursor to be destroyed. The cursor must not be in use.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>DestroyCursor</b> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor: </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[SupportedOSPlatform("windows5.0")]
		internal static winmdroot.Foundation.BOOL DestroyCursor(winmdroot.UI.WindowsAndMessaging.HCURSOR hCursor)
		{
			Marshal.SetLastSystemError(0);
			winmdroot.Foundation.BOOL __retVal = LocalExternFunction(hCursor);
			Marshal.SetLastPInvokeError(Marshal.GetLastSystemError());
			return __retVal;

			[DllImport("USER32.dll", ExactSpelling = true, EntryPoint = "DestroyCursor")]
			static extern winmdroot.Foundation.BOOL LocalExternFunction(winmdroot.UI.WindowsAndMessaging.HCURSOR hCursor);
		}

		/// <inheritdoc cref="GetCursor()"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe DestroyCursorSafeHandle GetCursor_SafeHandle()
		{
			winmdroot.UI.WindowsAndMessaging.HCURSOR __result = PInvoke.GetCursor();
			return new DestroyCursorSafeHandle(__result, ownsHandle: true);
		}

		/// <summary>Retrieves a handle to the current cursor.</summary>
		/// <returns>
		/// <para>Type: <b>HCURSOR</b> The return value is the handle to the current cursor. If there is no cursor, the return value is <b>NULL</b>.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcursor">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("USER32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern winmdroot.UI.WindowsAndMessaging.HCURSOR GetCursor();
	}


	/// <content>
	/// Contains extern methods from "SHELL32.dll".
	/// </content>
	internal static partial class PInvoke
	{
		/// <inheritdoc cref="ExtractIcon(winmdroot.Foundation.HINSTANCE, winmdroot.Foundation.PCWSTR, uint)"/>
		[SupportedOSPlatform("windows5.1.2600")]
		internal static unsafe DestroyIconSafeHandle ExtractIcon(string pszExeFileName, uint nIconIndex)
		{
			fixed (char* pszExeFileNameLocal = pszExeFileName)
			{
				winmdroot.UI.WindowsAndMessaging.HICON __result = PInvoke.ExtractIcon(default, pszExeFileNameLocal, nIconIndex);
				return new DestroyIconSafeHandle(__result, ownsHandle: true);
			}
		}

		/// <summary>Gets a handle to an icon from the specified executable file, DLL, or icon file. To retrieve an array of handles to large or small icons, use the ExtractIconEx function. (Unicode)</summary>
		/// <param name="hInst">
		/// <para>Type: <b>HINSTANCE</b> Handle to the instance of the application that calls the function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="pszExeFileName">
		/// <para>Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="nIconIndex">
		/// <para>Type: <b>UINT</b> Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file.</para>
		/// <para>If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1. If this value is a negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-extracticonexa">ExtractIconEx</a> function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HICON</b> The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.</para>
		/// </returns>
		/// <remarks>
		/// <para>When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.</para>
		/// <para>> [!NOTE] > The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("SHELL32.dll", ExactSpelling = true, EntryPoint = "ExtractIconW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.1.2600")]
		internal static extern winmdroot.UI.WindowsAndMessaging.HICON ExtractIcon(winmdroot.Foundation.HINSTANCE hInst, winmdroot.Foundation.PCWSTR pszExeFileName, uint nIconIndex);

		/// <inheritdoc cref="ExtractIconEx(winmdroot.Foundation.PCWSTR, int, winmdroot.UI.WindowsAndMessaging.HICON*, winmdroot.UI.WindowsAndMessaging.HICON*, uint)"/>
		[SupportedOSPlatform("windows5.1.2600")]
		internal static unsafe uint ExtractIconEx(string lpszFile, int nIconIndex, out DestroyIconSafeHandle phiconLarge, out DestroyIconSafeHandle phiconSmall, uint nIcons)
		{
			fixed (char* lpszFileLocal = lpszFile)
			{
				winmdroot.UI.WindowsAndMessaging.HICON phiconLargeLocal;
				winmdroot.UI.WindowsAndMessaging.HICON phiconSmallLocal;
				uint __result = PInvoke.ExtractIconEx(lpszFileLocal, nIconIndex, &phiconLargeLocal, &phiconSmallLocal, nIcons);
				phiconLarge = new DestroyIconSafeHandle(phiconLargeLocal, ownsHandle: true);
				phiconSmall = new DestroyIconSafeHandle(phiconSmallLocal, ownsHandle: true);
				return __result;
			}
		}

		/// <summary>The ExtractIconEx function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file. (Unicode)</summary>
		/// <param name="lpszFile">
		/// <para>Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="nIconIndex">
		/// <para>Type: <b>int</b> Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file.</para>
		/// <para>If this value is –1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1. If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="phiconLarge">
		/// <para>Type: <b>HICON*</b> Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="phiconSmall">
		/// <para>Type: <b>HICON*</b> Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="nIcons">
		/// <para>Type: <b>UINT</b> The number of icons to extract from the file.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Type: **UINT** If the *nIconIndex* parameter is -1 and both the *phiconLarge* and *phiconSmall* parameters are **NULL**, then the return value is the number of icons contained in the specified file. If the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**, the return value is the number of icons successfully extracted from the file. > [!NOTE] > If the function encounters an error, it returns **UINT_MAX**. In this case, you can call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to retrieve the error code. For example, this function returns **UINT_MAX** if the file specified by *lpszFile* cannot be found while the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**. In this case, **GetLastError** returns **ERROR_FILE_NOT_FOUND** (2).</para>
		/// </returns>
		/// <remarks>
		/// <para>When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function. To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.</para>
		/// <para>> [!NOTE] > The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[SupportedOSPlatform("windows5.1.2600")]
		internal static unsafe uint ExtractIconEx(winmdroot.Foundation.PCWSTR lpszFile, int nIconIndex, [Optional] winmdroot.UI.WindowsAndMessaging.HICON* phiconLarge, [Optional] winmdroot.UI.WindowsAndMessaging.HICON* phiconSmall, uint nIcons)
		{
			Marshal.SetLastSystemError(0);
			uint __retVal = LocalExternFunction(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
			Marshal.SetLastPInvokeError(Marshal.GetLastSystemError());
			return __retVal;

			[DllImport("SHELL32.dll", ExactSpelling = true, EntryPoint = "ExtractIconExW")]
			static extern unsafe uint LocalExternFunction(winmdroot.Foundation.PCWSTR lpszFile, int nIconIndex, [Optional] winmdroot.UI.WindowsAndMessaging.HICON* phiconLarge, [Optional] winmdroot.UI.WindowsAndMessaging.HICON* phiconSmall, uint nIcons);
		}
	}


	/// <content>
	/// Contains extern methods from "OLE32.dll".
	/// </content>
	internal static partial class PInvoke
	{
		/// <inheritdoc cref="CoCreateInstance(Guid*, global::Windows.Win32.System.Com.IUnknown*, global::Windows.Win32.System.Com.CLSCTX, Guid*, void**)"/>
		internal static unsafe global::Windows.Win32.Foundation.HRESULT CoCreateInstance<T>(in Guid rclsid, global::Windows.Win32.System.Com.IUnknown* pUnkOuter, global::Windows.Win32.System.Com.CLSCTX dwClsContext, out T* ppv)
where T : unmanaged

		{
			global::Windows.Win32.Foundation.HRESULT hr = CoCreateInstance(rclsid, pUnkOuter, dwClsContext, typeof(T).GUID, out void* o);
			ppv = (T*)o;
			return hr;
		}

		/// <inheritdoc cref="CoCreateInstance(global::System.Guid*, winmdroot.System.Com.IUnknown*, winmdroot.System.Com.CLSCTX, global::System.Guid*, void**)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.HRESULT CoCreateInstance(in global::System.Guid rclsid, winmdroot.System.Com.IUnknown* pUnkOuter, winmdroot.System.Com.CLSCTX dwClsContext, in global::System.Guid riid, out void* ppv)
		{
			fixed (void** ppvLocal = &ppv)
			{
				fixed (global::System.Guid* riidLocal = &riid)
				{
					fixed (global::System.Guid* rclsidLocal = &rclsid)
					{
						winmdroot.Foundation.HRESULT __result = PInvoke.CoCreateInstance(rclsidLocal, pUnkOuter, dwClsContext, riidLocal, ppvLocal);
						return __result;
					}
				}
			}
		}

		/// <summary>Creates a single uninitialized object of the class associated with a specified CLSID.</summary>
		/// <param name="rclsid">The CLSID associated with the data and code that will be used to create the object.</param>
		/// <param name="pUnkOuter">If <b>NULL</b>, indicates that the object is not being created as part of an aggregate. If non-<b>NULL</b>, pointer to the aggregate object's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface (the controlling <b>IUnknown</b>).</param>
		/// <param name="dwClsContext">Context in which the code that manages the newly created object will run. The values are taken from the enumeration <a href="https://docs.microsoft.com/windows/desktop/api/wtypesbase/ne-wtypesbase-clsctx">CLSCTX</a>.</param>
		/// <param name="riid">A reference to the identifier of the interface to be used to communicate with the object.</param>
		/// <param name="ppv">Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return, *<i>ppv</i> contains the requested interface pointer. Upon failure, *<i>ppv</i> contains <b>NULL</b>.</param>
		/// <returns>
		/// <para>This function can return the following values. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>CoCreateInstance</b> function provides a convenient shortcut by connecting to the class object associated with the specified CLSID, creating a default-initialized instance, and releasing the class object. As such, it encapsulates the following functionality:</para>
		/// <para></para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("OLE32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.HRESULT CoCreateInstance(global::System.Guid* rclsid, [Optional] winmdroot.System.Com.IUnknown* pUnkOuter, winmdroot.System.Com.CLSCTX dwClsContext, global::System.Guid* riid, void** ppv);

		/// <inheritdoc cref="CoInitialize(void*)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.HRESULT CoInitialize()
		{
			winmdroot.Foundation.HRESULT __result = PInvoke.CoInitialize(default);
			return __result;
		}

		/// <summary>Initializes the COM library on the current thread and identifies the concurrency model as single-thread apartment (STA).</summary>
		/// <param name="pvReserved">This parameter is reserved and must be <b>NULL</b>.</param>
		/// <returns>
		/// <para>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>You need to initialize the COM library on a thread before you call any of the library functions except <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmalloc">CoGetMalloc</a>, to get a pointer to the standard allocator, and the memory allocation functions.</para>
		/// <para>After the concurrency model for a thread is set, it cannot be changed. A call to <b>CoInitialize</b> on an apartment that was previously initialized as multithreaded will fail and return RPC_E_CHANGED_MODE.</para>
		/// <para><a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a> provides the same functionality as <b>CoInitialize</b> and also provides a parameter to explicitly specify the thread's concurrency model. <b>CoInitialize</b> calls <b>CoInitializeEx</b> and specifies the concurrency model as single-thread apartment. Applications developed today should call <b>CoInitializeEx</b> rather than <b>CoInitialize</b>.</para>
		/// <para>Typically, the COM library is initialized on a thread only once. Subsequent calls to <b>CoInitialize</b> or <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a> on the same thread will succeed, as long as they do not attempt to change the concurrency model, but will return S_FALSE. To close the COM library gracefully, each successful call to <b>CoInitialize</b> or <b>CoInitializeEx</b>, including those that return S_FALSE, must be balanced by a corresponding call to <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize">CoUninitialize</a>. However, the first thread in the application that calls <b>CoInitialize</b> with 0 (or <b>CoInitializeEx</b> with COINIT_APARTMENTTHREADED) must be the last thread to call <b>CoUninitialize</b>. Otherwise, subsequent calls to <b>CoInitialize</b> on the STA will fail and the application will not work. Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call <b>CoInitialize</b>, <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize">CoUninitialize</a> from the <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/objbase/nf-objbase-coinitialize#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("OLE32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.HRESULT CoInitialize([Optional] void* pvReserved);

		/// <summary>Closes the COM library on the current thread, unloads all DLLs loaded by the thread, frees any other resources that the thread maintains, and forces all RPC connections on the thread to close.</summary>
		/// <remarks>
		/// <para>A thread must call <b>CoUninitialize</b> once for each successful call it has made to the <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a> function, including any call that returns S_FALSE. Only the <b>CoUninitialize</b> call corresponding to the <b>CoInitialize</b> or <b>CoInitializeEx</b> call that initialized the library can close it.</para>
		/// <para>Calls to <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a> must be balanced by calls to <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleuninitialize">OleUninitialize</a>. The <b>OleUninitialize</b> function calls <b>CoUninitialize</b> internally, so applications that call <b>OleUninitialize</b> do not also need to call <b>CoUninitialize</b>.</para>
		/// <para><b>CoUninitialize</b> should be called on application shutdown, as the last call made to the COM library after the application hides its main windows and falls through its main message loop. If there are open conversations remaining, <b>CoUninitialize</b> starts a modal message loop and dispatches any pending messages from the containers or server for this COM application. By dispatching the messages, <b>CoUninitialize</b> ensures that the application does not quit before receiving all of its pending messages. Non-COM messages are discarded.</para>
		/// <para>Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a>, <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a>, or <b>CoUninitialize</b> from the <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-couninitialize#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("OLE32.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern void CoUninitialize();
	}

	internal static unsafe partial class ComHelpers
	{
		private static readonly winmdroot.Foundation.HRESULT COR_E_OBJECTDISPOSED = (winmdroot.Foundation.HRESULT)unchecked((int)0x80131622);

		private static readonly winmdroot.Foundation.HRESULT S_OK = (winmdroot.Foundation.HRESULT)0;


		internal static winmdroot.Foundation.HRESULT UnwrapCCW<TThis, TInterface>(TThis* @this, out TInterface @object)
where TThis : unmanaged
where TInterface : class

		{
			@object = ComWrappers.ComInterfaceDispatch.GetInstance<TInterface>((ComWrappers.ComInterfaceDispatch*)@this);
			return @object is null ? COR_E_OBJECTDISPOSED : S_OK;
		}


		internal static void PopulateIUnknown<TComInterface>(System.Com.IUnknown.Vtbl* vtable)
where TComInterface : unmanaged

		{
			PopulateIUnknownImpl<TComInterface>(vtable);
			if (vtable->QueryInterface_1 is null)

			{
				throw new NotImplementedException("v-tables cannot be accessed unless the Windows.Win32.ComHelpers.PopulateIUnknownImpl partial method is implemented.");
			}
		}


		static partial void PopulateIUnknownImpl<TComInterface>(System.Com.IUnknown.Vtbl* vtable)
where TComInterface : unmanaged;
	}
	/// <summary>
	/// Non generic interface that allows constraining against a COM wrapper type directly. COM structs should
	/// implement <see cref="IVTable{TComInterface, TVTable}"/>.
	/// </summary>
	internal unsafe interface IVTable
	{
		static abstract System.Com.IUnknown.Vtbl* VTable 		{
			get; 		}
	}
	internal unsafe interface IVTable<TComInterface, TVTable> 		: IVTable
where TVTable : unmanaged
where TComInterface : unmanaged, IVTable<TComInterface, TVTable>
	{
		private protected static abstract void PopulateVTable(TVTable* vtable);


		static System.Com.IUnknown.Vtbl* IVTable.VTable 		{
			get; 		}
= (System.Com.IUnknown.Vtbl*)CreateVTable();


		private static TVTable* CreateVTable()

		{
			TVTable* vtbl = (TVTable*)RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(TVTable), sizeof(TVTable));
			ComHelpers.PopulateIUnknown<TComInterface>((System.Com.IUnknown.Vtbl*)vtbl);
			TComInterface.PopulateVTable(vtbl);
			return vtbl;
		}
	}
	internal interface IComIID
	{
		/// <summary>The IID guid for this interface.</summary>
		/// <remarks>The <see cref="Guid" /> reference that is returned comes from a permanent memory address, and is therefore safe to convert to a pointer and pass around or hold long-term.</remarks>
		internal static abstract ref readonly Guid Guid		{
			get;
		}
	}


	/// <summary>
	/// Represents a Win32 handle that can be closed with <see cref="PInvoke.DestroyIcon(winmdroot.UI.WindowsAndMessaging.HICON)"/>.
	/// </summary>
	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
	internal class DestroyIconSafeHandle
		:SafeHandle	{
		private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1L);

		internal DestroyIconSafeHandle():base(INVALID_HANDLE_VALUE, true)
		{
		}

		internal DestroyIconSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true):base(INVALID_HANDLE_VALUE, ownsHandle)
		{
			this.SetHandle(preexistingHandle);
		}

		public override bool IsInvalid => this.handle.ToInt64() == -1L || this.handle.ToInt64() == 0L;

		protected override bool ReleaseHandle() => PInvoke.DestroyIcon((winmdroot.UI.WindowsAndMessaging.HICON)this.handle);
	}


	/// <summary>
	/// Represents a Win32 handle that can be closed with <see cref="PInvoke.DestroyCursor(winmdroot.UI.WindowsAndMessaging.HCURSOR)"/>.
	/// </summary>
	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
	internal class DestroyCursorSafeHandle
		:SafeHandle	{
		private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1L);

		internal DestroyCursorSafeHandle():base(INVALID_HANDLE_VALUE, true)
		{
		}

		internal DestroyCursorSafeHandle(IntPtr preexistingHandle, bool ownsHandle = true):base(INVALID_HANDLE_VALUE, ownsHandle)
		{
			this.SetHandle(preexistingHandle);
		}

		public override bool IsInvalid => this.handle.ToInt64() == -1L || this.handle.ToInt64() == 0L;

		protected override bool ReleaseHandle() => PInvoke.DestroyCursor((winmdroot.UI.WindowsAndMessaging.HCURSOR)this.handle);
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_260
	{
		private const int SpanLength = 260;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;

		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(in Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();

		public static implicit operator __char_260(string value) => value.AsSpan();

		public static implicit operator __char_260(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_260 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_14
	{
		private const int SpanLength = 14;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;

		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(in Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();

		public static implicit operator __char_14(string value) => value.AsSpan();

		public static implicit operator __char_14(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_14 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	internal partial struct __byte_1
	{
		private const int SpanLength = 1;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;

		internal unsafe fixed byte Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref byte this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<byte> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<byte> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(in Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<byte> value) => AsReadOnlySpan().SequenceEqual(value);

		public static implicit operator __byte_1(ReadOnlySpan<byte> value)
		{
			Unsafe.SkipInit(out __byte_1 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
	internal static partial class InlineArrayIndexerExtensions
	{
		internal static ReadOnlySpan<char> SliceAtNull(this ReadOnlySpan<char>value)
		{
			int length = value.IndexOf('\0');
			return length < 0 ? value : value.Slice(0, length);
		}

		internal static unsafe ref readonly char ReadOnlyItemRef(this in winmdroot.__char_260 @this, int index) => ref @this.Value[index];

		internal static unsafe ref readonly char ReadOnlyItemRef(this in winmdroot.__char_14 @this, int index) => ref @this.Value[index];

		internal static unsafe ref readonly byte ReadOnlyItemRef(this in winmdroot.__byte_1 @this, int index) => ref @this.Value[index];
	}

	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
	internal static partial class System_Com_IPersist_Extensions
	{
		/// <inheritdoc cref="winmdroot.System.Com.IPersist.Interface.GetClassID(global::System.Guid*)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetClassID(this winmdroot.System.Com.IPersist.Interface @this, out global::System.Guid pClassID)
		{
			fixed (global::System.Guid* pClassIDLocal = &pClassID)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetClassID(pClassIDLocal);
				return __result;
			}
		}
	}

	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
	internal static partial class System_Com_IPersistFile_Extensions
	{
		/// <inheritdoc cref="winmdroot.System.Com.IPersistFile.Interface.GetClassID(global::System.Guid*)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetClassID(this winmdroot.System.Com.IPersistFile.Interface @this, out global::System.Guid pClassID)
		{
			fixed (global::System.Guid* pClassIDLocal = &pClassID)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetClassID(pClassIDLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.System.Com.IPersistFile.Interface.Load(winmdroot.Foundation.PCWSTR, winmdroot.System.Com.STGM)"/>
		internal static unsafe winmdroot.Foundation.HRESULT Load(this winmdroot.System.Com.IPersistFile.Interface @this, string pszFileName, winmdroot.System.Com.STGM dwMode)
		{
			fixed (char* pszFileNameLocal = pszFileName)
			{
				winmdroot.Foundation.HRESULT __result = @this.Load(pszFileNameLocal, dwMode);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.System.Com.IPersistFile.Interface.Save(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.BOOL)"/>
		internal static unsafe winmdroot.Foundation.HRESULT Save(this winmdroot.System.Com.IPersistFile.Interface @this, string pszFileName, winmdroot.Foundation.BOOL fRemember)
		{
			fixed (char* pszFileNameLocal = pszFileName)
			{
				winmdroot.Foundation.HRESULT __result = @this.Save(pszFileNameLocal, fRemember);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.System.Com.IPersistFile.Interface.SaveCompleted(winmdroot.Foundation.PCWSTR)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SaveCompleted(this winmdroot.System.Com.IPersistFile.Interface @this, string pszFileName)
		{
			fixed (char* pszFileNameLocal = pszFileName)
			{
				winmdroot.Foundation.HRESULT __result = @this.SaveCompleted(pszFileNameLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.System.Com.IPersistFile.Interface.GetCurFile(winmdroot.Foundation.PWSTR*)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetCurFile(this winmdroot.System.Com.IPersistFile.Interface @this, out winmdroot.Foundation.PWSTR ppszFileName)
		{
			fixed (winmdroot.Foundation.PWSTR* ppszFileNameLocal = &ppszFileName)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetCurFile(ppszFileNameLocal);
				return __result;
			}
		}
	}

	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
	internal static partial class UI_Shell_IShellLinkW_Extensions
	{
		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.GetPath(winmdroot.Foundation.PWSTR, int, winmdroot.Storage.FileSystem.WIN32_FIND_DATAW*, uint)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetPath(this winmdroot.UI.Shell.IShellLinkW.Interface @this, winmdroot.Foundation.PWSTR pszFile, int cch, ref winmdroot.Storage.FileSystem.WIN32_FIND_DATAW pfd, uint fFlags)
		{
			fixed (winmdroot.Storage.FileSystem.WIN32_FIND_DATAW* pfdLocal = &pfd)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetPath(pszFile, cch, pfdLocal, fFlags);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.GetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST**)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetIDList(this winmdroot.UI.Shell.IShellLinkW.Interface @this, out winmdroot.UI.Shell.Common.ITEMIDLIST* ppidl)
		{
			fixed (winmdroot.UI.Shell.Common.ITEMIDLIST** ppidlLocal = &ppidl)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetIDList(ppidlLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.SetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST*)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SetIDList(this winmdroot.UI.Shell.IShellLinkW.Interface @this, in winmdroot.UI.Shell.Common.ITEMIDLIST pidl)
		{
			fixed (winmdroot.UI.Shell.Common.ITEMIDLIST* pidlLocal = &pidl)
			{
				winmdroot.Foundation.HRESULT __result = @this.SetIDList(pidlLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.SetDescription(winmdroot.Foundation.PCWSTR)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SetDescription(this winmdroot.UI.Shell.IShellLinkW.Interface @this, string pszName)
		{
			fixed (char* pszNameLocal = pszName)
			{
				winmdroot.Foundation.HRESULT __result = @this.SetDescription(pszNameLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.SetWorkingDirectory(winmdroot.Foundation.PCWSTR)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SetWorkingDirectory(this winmdroot.UI.Shell.IShellLinkW.Interface @this, string pszDir)
		{
			fixed (char* pszDirLocal = pszDir)
			{
				winmdroot.Foundation.HRESULT __result = @this.SetWorkingDirectory(pszDirLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.SetArguments(winmdroot.Foundation.PCWSTR)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SetArguments(this winmdroot.UI.Shell.IShellLinkW.Interface @this, string pszArgs)
		{
			fixed (char* pszArgsLocal = pszArgs)
			{
				winmdroot.Foundation.HRESULT __result = @this.SetArguments(pszArgsLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.GetHotkey(ushort*)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetHotkey(this winmdroot.UI.Shell.IShellLinkW.Interface @this, out ushort pwHotkey)
		{
			fixed (ushort* pwHotkeyLocal = &pwHotkey)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetHotkey(pwHotkeyLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.GetShowCmd(winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD*)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetShowCmd(this winmdroot.UI.Shell.IShellLinkW.Interface @this, out winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD piShowCmd)
		{
			fixed (winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD* piShowCmdLocal = &piShowCmd)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetShowCmd(piShowCmdLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.GetIconLocation(winmdroot.Foundation.PWSTR, int, int*)"/>
		internal static unsafe winmdroot.Foundation.HRESULT GetIconLocation(this winmdroot.UI.Shell.IShellLinkW.Interface @this, winmdroot.Foundation.PWSTR pszIconPath, int cch, out int piIcon)
		{
			fixed (int* piIconLocal = &piIcon)
			{
				winmdroot.Foundation.HRESULT __result = @this.GetIconLocation(pszIconPath, cch, piIconLocal);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.SetIconLocation(winmdroot.Foundation.PCWSTR, int)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SetIconLocation(this winmdroot.UI.Shell.IShellLinkW.Interface @this, string pszIconPath, int iIcon)
		{
			fixed (char* pszIconPathLocal = pszIconPath)
			{
				winmdroot.Foundation.HRESULT __result = @this.SetIconLocation(pszIconPathLocal, iIcon);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.SetRelativePath(winmdroot.Foundation.PCWSTR, uint)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SetRelativePath(this winmdroot.UI.Shell.IShellLinkW.Interface @this, string pszPathRel, uint dwReserved)
		{
			fixed (char* pszPathRelLocal = pszPathRel)
			{
				winmdroot.Foundation.HRESULT __result = @this.SetRelativePath(pszPathRelLocal, dwReserved);
				return __result;
			}
		}

		/// <inheritdoc cref="winmdroot.UI.Shell.IShellLinkW.Interface.SetPath(winmdroot.Foundation.PCWSTR)"/>
		internal static unsafe winmdroot.Foundation.HRESULT SetPath(this winmdroot.UI.Shell.IShellLinkW.Interface @this, string pszFile)
		{
			fixed (char* pszFileLocal = pszFile)
			{
				winmdroot.Foundation.HRESULT __result = @this.SetPath(pszFileLocal);
				return __result;
			}
		}
	}

	internal static partial class PInvoke
	{
		internal const uint MAX_PATH = 260U;
	}

	namespace Foundation
	{
		/// <remarks>
		/// <para>The **HRESULT** data type is the same as the [SCODE](scode.md) data type. An **HRESULT** value consists of the following fields: - A 1-bit code indicating severity, where zero represents success and 1 represents failure. - A 4-bit reserved value. - An 11-bit code indicating responsibility for the error or warning, also known as a facility code. - A 16-bit code describing the error or warning. Most MAPI interface methods and functions return **HRESULT** values to provide detailed cause formation. **HRESULT** values are also used widely in OLE interface methods. OLE provides several macros for converting between **HRESULT** values and **SCODE** values, another common data type for error handling. > [!NOTE] > In 64-bit MAPI, **HRESULT** is still a 32-bit value. For information about the OLE use of **HRESULT** values, see the  *OLE Programmer's Reference*. For more information about the use of these values in MAPI, see [Error Handling](error-handling-in-mapi.md) and any of the following interface methods: [IABLogon::GetLastError](iablogon-getlasterror.md) [IMAPISupport::GetLastError](imapisupport-getlasterror.md) [IMAPIControl::GetLastError](imapicontrol-getlasterror.md) [IMAPITable::GetLastError](imapitable-getlasterror.md) [IMAPIProp::GetLastError](imapiprop-getlasterror.md) [IMAPIViewAdviseSink::OnPrint](imapiviewadvisesink-onprint.md)</para>
		/// <para><see href="https://learn.microsoft.com/office/client-developer/outlook/mapi/hresult#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct HRESULT
			: IEquatable<HRESULT>
		{
			internal readonly int Value;

			internal HRESULT(int value) => this.Value = value;

			public static implicit operator int(HRESULT value) => value.Value;

			public static explicit operator HRESULT(int value) => new HRESULT(value);

			public static bool operator ==(HRESULT left, HRESULT right) => left.Value == right.Value;

			public static bool operator !=(HRESULT left, HRESULT right) => !(left == right);

			public bool Equals(HRESULT other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is HRESULT other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();


			public override string ToString() => string.Format(global::System.Globalization.CultureInfo.InvariantCulture, "0x{0:X8}", this.Value);

			public static implicit operator uint(HRESULT value) => (uint)value.Value;

			public static explicit operator HRESULT(uint value) => new HRESULT((int)value);


			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			internal bool Succeeded => this.Value >= 0;


			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			internal bool Failed => this.Value < 0;


			/// <inheritdoc cref="Marshal.ThrowExceptionForHR(int, IntPtr)" />
			/// <param name="errorInfo">
			/// A pointer to the IErrorInfo interface that provides more information about the
			/// error. You can specify <see cref="IntPtr.Zero"/> to use the current IErrorInfo interface, or
			/// <c>new IntPtr(-1)</c> to ignore the current IErrorInfo interface and construct the exception
			/// just from the error code.
			/// </param>
			/// <returns><see langword="this"/> <see cref="HRESULT"/>, if it does not reflect an error.</returns>
			/// <seealso cref="Marshal.ThrowExceptionForHR(int, IntPtr)"/>
			internal HRESULT ThrowOnFailure(IntPtr errorInfo = default)

			{
				Marshal.ThrowExceptionForHR(this.Value, errorInfo);
				return this;
			}


			internal string ToString(string format, IFormatProvider formatProvider) => ((uint)this.Value).ToString(format, formatProvider);
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct BOOL
			: IEquatable<BOOL>
		{
			internal readonly int Value;

			internal BOOL(int value) => this.Value = value;

			public static implicit operator int(BOOL value) => value.Value;

			public static explicit operator BOOL(int value) => new BOOL(value);

			public static bool operator ==(BOOL left, BOOL right) => left.Value == right.Value;

			public static bool operator !=(BOOL left, BOOL right) => !(left == right);

			public bool Equals(BOOL other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is BOOL other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();

			public override string ToString() => $"0x{this.Value:x}";

			internal BOOL(bool value) => this.Value = value ? 1 : 0;

			public static implicit operator bool(BOOL value) => value.Value != 0;

			public static implicit operator BOOL(bool value) => new BOOL(value);
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal unsafe readonly partial struct PWSTR
			: IEquatable<PWSTR>
		{
			internal readonly char* Value;

			internal PWSTR(char* value) => this.Value = value;

			public static implicit operator char*(PWSTR value) => value.Value;

			public static implicit operator PWSTR(char* value) => new PWSTR(value);

			public static bool operator ==(PWSTR left, PWSTR right) => left.Value == right.Value;

			public static bool operator !=(PWSTR left, PWSTR right) => !(left == right);

			public bool Equals(PWSTR other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is PWSTR other && this.Equals(other);

			public override int GetHashCode() => unchecked((int)this.Value);


			/// <inheritdoc cref="PCWSTR.ToString()"/>
			public override string ToString() => new PCWSTR(this.Value).ToString();

			public static implicit operator PCWSTR(PWSTR value) => new PCWSTR(value.Value);


			/// <inheritdoc cref="PCWSTR.Length"/>
			internal int Length => new PCWSTR(this.Value).Length;


			/// <summary>
			/// Returns a span of the characters in this string, up to the first null character (exclusive).
			/// </summary>
			internal Span<char> AsSpan() => this.Value is null ? default(Span<char>) : new Span<char>(this.Value, this.Length);


			private string DebuggerDisplay => this.ToString();
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct HANDLE
			: IEquatable<HANDLE>
		{
			internal readonly IntPtr Value;

			internal HANDLE(IntPtr value) => this.Value = value;

			internal static HANDLE Null => default;

			internal bool IsNull => Value == default;

			public static implicit operator IntPtr(HANDLE value) => value.Value;

			public static explicit operator HANDLE(IntPtr value) => new HANDLE(value);

			public static bool operator ==(HANDLE left, HANDLE right) => left.Value == right.Value;

			public static bool operator !=(HANDLE left, HANDLE right) => !(left == right);

			public bool Equals(HANDLE other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is HANDLE other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();

			public override string ToString() => $"0x{this.Value:x}";
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct HWND
			: IEquatable<HWND>
		{
			internal readonly IntPtr Value;

			internal HWND(IntPtr value) => this.Value = value;

			internal static HWND Null => default;

			internal bool IsNull => Value == default;

			public static implicit operator IntPtr(HWND value) => value.Value;

			public static explicit operator HWND(IntPtr value) => new HWND(value);

			public static bool operator ==(HWND left, HWND right) => left.Value == right.Value;

			public static bool operator !=(HWND left, HWND right) => !(left == right);

			public bool Equals(HWND other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is HWND other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();

			public override string ToString() => $"0x{this.Value:x}";

			public static implicit operator HANDLE(HWND value) => new HANDLE(value.Value);
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct HMODULE
			: IEquatable<HMODULE>
		{
			internal readonly IntPtr Value;

			internal HMODULE(IntPtr value) => this.Value = value;

			internal static HMODULE Null => default;

			internal bool IsNull => Value == default;

			public static implicit operator IntPtr(HMODULE value) => value.Value;

			public static explicit operator HMODULE(IntPtr value) => new HMODULE(value);

			public static bool operator ==(HMODULE left, HMODULE right) => left.Value == right.Value;

			public static bool operator !=(HMODULE left, HMODULE right) => !(left == right);

			public bool Equals(HMODULE other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is HMODULE other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();

			public override string ToString() => $"0x{this.Value:x}";

			public static implicit operator HINSTANCE(HMODULE value) => new HINSTANCE(value.Value);
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct HINSTANCE
			: IEquatable<HINSTANCE>
		{
			internal readonly IntPtr Value;

			internal HINSTANCE(IntPtr value) => this.Value = value;

			internal static HINSTANCE Null => default;

			internal bool IsNull => Value == default;

			public static implicit operator IntPtr(HINSTANCE value) => value.Value;

			public static explicit operator HINSTANCE(IntPtr value) => new HINSTANCE(value);

			public static bool operator ==(HINSTANCE left, HINSTANCE right) => left.Value == right.Value;

			public static bool operator !=(HINSTANCE left, HINSTANCE right) => !(left == right);

			public bool Equals(HINSTANCE other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is HINSTANCE other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();

			public override string ToString() => $"0x{this.Value:x}";

			public static implicit operator HMODULE(HINSTANCE value) => new HMODULE(value.Value);
		}

		/// <summary>
		/// A pointer to a null-terminated, constant character string.
		/// </summary>
		[DebuggerDisplay("{" + nameof(DebuggerDisplay) + "}")]
		internal unsafe readonly partial struct PCWSTR
			: IEquatable<PCWSTR>
		{
			/// <summary>
			/// A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
			/// </summary>
			internal readonly char* Value;

			internal PCWSTR(char* value) => this.Value = value;

			public static explicit operator char*(PCWSTR value) => value.Value;

			public static implicit operator PCWSTR(char* value) => new PCWSTR(value);

			public bool Equals(PCWSTR other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is PCWSTR other && this.Equals(other);

			public override int GetHashCode() => unchecked((int)this.Value);


			/// <summary>
			/// Gets the number of characters up to the first null character (exclusive).
			/// </summary>
			internal int Length
			{
				get
				{
					char* p = this.Value;
					if (p is null)
						return 0;
					while (*p != '\0')
						p++;
					return checked((int)(p - this.Value));
				}
			}


			/// <summary>
			/// Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
			/// </summary>
			/// <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="Value"/> is <see langword="null"/>.</returns>
			public override string ToString() => this.Value is null ? null : new string(this.Value);


			/// <summary>
			/// Returns a span of the characters in this string, up to the first null character (exclusive).
			/// </summary>
			internal ReadOnlySpan<char> AsSpan() => this.Value is null ? default(ReadOnlySpan<char>) : new ReadOnlySpan<char>(this.Value, this.Length);


			private string DebuggerDisplay => this.ToString();
		}
	}

	namespace System.Com
	{
		[Guid("00000000-0000-0000-C000-000000000046")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal unsafe partial struct IUnknown
			:IComIID		{
			/// <inheritdoc cref="QueryInterface(global::System.Guid*, void**)"/>
			internal unsafe winmdroot.Foundation.HRESULT QueryInterface(in global::System.Guid riid, out void* ppvObject)
			{
				fixed (void** ppvObjectLocal = &ppvObject)
				{
					fixed (global::System.Guid* riidLocal = &riid)
					{
						winmdroot.Foundation.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
						return __result;
					}
				}
			}

			/// <summary>Retrieves pointers to the supported interfaces on an object.</summary>
			/// <param name="riid">
			/// <para>Type: **REFIID** A reference to the interface identifier (IID) of the interface being queried for.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="ppvObject">
			/// <para>Type: **[void](/windows/desktop/winprog/windows-data-types)\*\*** The address of a pointer to an interface with the IID specified in the *riid* parameter. Because you pass the address of an interface pointer, the method can overwrite that address with the pointer to the interface being queried for. Upon successful return, *\*ppvObject* (the dereferenced address) contains a pointer to the requested interface. If the object doesn't support the interface, the method sets *\*ppvObject* (the dereferenced address) to `nullptr`.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>This method returns **S_OK** if the interface is supported, and **E_NOINTERFACE** otherwise. If *ppvObject* (the address) is `nullptr`, then this method returns **E_POINTER**.</returns>
			/// <remarks>
			/// <para>For any given COM object (also known as a COM component), a specific query for the [IUnknown interface](/windows/desktop/api/unknwn/nn-unknwn-iunknown) on any of the object's interfaces must always return the same pointer value. This enables a client to determine whether two pointers point to the same component by calling **QueryInterface** with **IID_IUnknown** and comparing the results. It is specifically not the case that queries for interfaces other than **IUnknown** (even the same interface through the same pointer) must return the same pointer value. There are four requirements for implementations of **QueryInterface** (In these cases, "must succeed" means "must succeed barring catastrophic failure."). - The set of interfaces accessible on an object through **QueryInterface** must be static, not dynamic. This means that if a call to **QueryInterface** for a pointer to a specified interface succeeds the first time, then it must succeed again. If the call fails the first time, then it must fail on all subsequent calls. - It must be reflexive&mdash;if a client holds a pointer to an interface on an object, and the client queries for that interface, then the call must succeed. - It must be symmetric&mdash;if a client holding a pointer to one interface queries successfully for another, then a query through the obtained pointer for the first interface must succeed. - It must be transitive&mdash;if a client holding a pointer to one interface queries successfully for a second, and through that pointer queries successfully for a third interface, then a query for the first interface through the pointer for the third interface must succeed.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public unsafe winmdroot.Foundation.HRESULT QueryInterface(global::System.Guid* riid, void** ppvObject)
			{
				return ((delegate *unmanaged [Stdcall]<IUnknown*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT>)lpVtbl[0])((IUnknown*)Unsafe.AsPointer(ref this), riid, ppvObject);
			}

			/// <summary>Increments the reference count for an interface pointer to a COM object. You should call this method whenever you make a copy of an interface pointer.</summary>
			/// <returns>The method returns the new reference count. This value is intended to be used only for test purposes.</returns>
			/// <remarks>
			/// <para>A COM object uses a per-interface reference-counting mechanism to ensure that the object doesn't outlive references to it. You use **AddRef** to stabilize a copy of an interface pointer. It can also be called when the life of a cloned pointer must extend beyond the lifetime of the original pointer. The cloned pointer must be released by calling [IUnknown::Release](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)) on it. The internal reference counter that **AddRef** maintains should be a 32-bit unsigned integer.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/unknwn/nf-unknwn-iunknown-addref#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public uint AddRef()
			{
				return ((delegate *unmanaged [Stdcall]<IUnknown*,uint>)lpVtbl[1])((IUnknown*)Unsafe.AsPointer(ref this));
			}

			/// <summary>Decrements the reference count for an interface on a COM object.</summary>
			/// <returns>The method returns the new reference count. This value is intended to be used only for test purposes.</returns>
			/// <remarks>
			/// <para>When the reference count on an object reaches zero, **Release** must cause the interface pointer to free itself. When the released pointer is the only (formerly) outstanding reference to an object (whether the object supports single or multiple interfaces), the implementation must free the object. Note that aggregation of objects restricts the ability to recover interface pointers.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/unknwn/nf-unknwn-iunknown-release#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public uint Release()
			{
				return ((delegate *unmanaged [Stdcall]<IUnknown*,uint>)lpVtbl[2])((IUnknown*)Unsafe.AsPointer(ref this));
			}

			internal struct Vtbl
			{
				internal delegate *unmanaged [Stdcall]<IUnknown*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT> QueryInterface_1;

				internal delegate *unmanaged [Stdcall]<IUnknown*,uint> AddRef_2;

				internal delegate *unmanaged [Stdcall]<IUnknown*,uint> Release_3;
			} 
			private void** lpVtbl;

			/// <summary>The IID guid for this interface.</summary>
			/// <value>{00000000-0000-0000-c000-000000000046}</value>
			internal static readonly Guid IID_Guid = new Guid(0x00000000, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

			static ref readonly Guid IComIID.Guid			{
								[MethodImpl(MethodImplOptions.AggressiveInlining)]
get
				{
					ReadOnlySpan<byte> data = new byte[]					{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46					};
					return ref Unsafe.As<byte,Guid>(ref MemoryMarshal.GetReference(data));
				}
			}
		}

		/// <summary>Flags that indicate conditions for creating and deleting the object and access modes for the object.</summary>
		/// <remarks>You can combine these flags, but you can only choose one flag from each group of related flags. Typically one flag from each of the access and sharing groups must be specified for all functions and methods which use these constants. Flags from other groups are optional.</remarks>
		[Flags]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal enum STGM : uint
		{
			STGM_DIRECT = 0x00000000,
			STGM_TRANSACTED = 0x00010000,
			STGM_SIMPLE = 0x08000000,
			STGM_READ = 0x00000000,
			STGM_WRITE = 0x00000001,
			STGM_READWRITE = 0x00000002,
			STGM_SHARE_DENY_NONE = 0x00000040,
			STGM_SHARE_DENY_READ = 0x00000030,
			STGM_SHARE_DENY_WRITE = 0x00000020,
			STGM_SHARE_EXCLUSIVE = 0x00000010,
			STGM_PRIORITY = 0x00040000,
			STGM_DELETEONRELEASE = 0x04000000,
			STGM_NOSCRATCH = 0x00100000,
			STGM_CREATE = 0x00001000,
			STGM_CONVERT = 0x00020000,
			STGM_FAILIFTHERE = 0x00000000,
			STGM_NOSNAPSHOT = 0x00200000,
			STGM_DIRECT_SWMR = 0x00400000,
		}

		[Guid("0000010C-0000-0000-C000-000000000046")]
		[SupportedOSPlatform("windows5.0")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal unsafe partial struct IPersist
			:IVTable<IPersist,IPersist.Vtbl>,IComIID		{
			/// <inheritdoc cref="QueryInterface(global::System.Guid*, void**)"/>
			internal unsafe winmdroot.Foundation.HRESULT QueryInterface(in global::System.Guid riid, out void* ppvObject)
			{
				fixed (void** ppvObjectLocal = &ppvObject)
				{
					fixed (global::System.Guid* riidLocal = &riid)
					{
						winmdroot.Foundation.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
						return __result;
					}
				}
			}

			public unsafe winmdroot.Foundation.HRESULT QueryInterface(global::System.Guid* riid, void** ppvObject)
			{
				return ((delegate *unmanaged [Stdcall]<IPersist*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT>)lpVtbl[0])((IPersist*)Unsafe.AsPointer(ref this), riid, ppvObject);
			}

			public uint AddRef()
			{
				return ((delegate *unmanaged [Stdcall]<IPersist*,uint>)lpVtbl[1])((IPersist*)Unsafe.AsPointer(ref this));
			}

			public uint Release()
			{
				return ((delegate *unmanaged [Stdcall]<IPersist*,uint>)lpVtbl[2])((IPersist*)Unsafe.AsPointer(ref this));
			}

			/// <inheritdoc cref="GetClassID(global::System.Guid*)"/>
			internal unsafe void GetClassID(out global::System.Guid pClassID)
			{
				fixed (global::System.Guid* pClassIDLocal = &pClassID)
				{
					this.GetClassID(pClassIDLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetClassID(IPersist* pThis, global::System.Guid* pClassID)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetClassID(pClassID);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Retrieves the class identifier (CLSID) of the object.</summary>
			/// <param name="pClassID">A pointer to the location that receives the CLSID on return. The CLSID is a globally unique identifier (GUID) that uniquely represents an object class that defines the code that can manipulate the object's data.</param>
			/// <returns>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</returns>
			/// <remarks>
			/// <para>The <b>GetClassID</b> method retrieves the class identifier (CLSID) for an object, used in later operations to load object-specific code into the caller's context. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> A container application might call this method to retrieve the original CLSID of an object that it is treating as a different class. Such a call would be necessary if a user performed an editing operation that required the object to be saved. If the container were to save it using the treat-as CLSID, the original application would no longer be able to edit the object. Typically, in this case, the container calls the <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-olesave">OleSave</a> helper function, which performs all the necessary steps. For this reason, most container applications have no need to call this method directly. The exception would be a container that provides an object handler for certain objects. In particular, a container application should not get an object's CLSID and then use it to retrieve class specific information from the registry. Instead, the container should use <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleobject">IOleObject</a> and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interfaces to retrieve such class-specific information directly from the object. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Typically, implementations of this method simply supply a constant CLSID for an object. If, however, the object's <b><a href="https://docs.microsoft.com/windows/desktop/com/treatas">TreatAs</a></b> registry key has been set by an application that supports emulation (and so is treating the object as one of a different class), a call to <b>GetClassID</b> must supply the CLSID specified in the <b><a href="https://docs.microsoft.com/windows/desktop/com/treatas">TreatAs</a></b> key. For more information on emulation, see <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-cotreatasclass">CoTreatAsClass</a>. When an object is in the running state, the default handler calls an implementation of <b>GetClassID</b> that delegates the call to the implementation in the object. When the object is not running, the default handler instead calls the <a href="https://docs.microsoft.com/windows/desktop/api/coml2api/nf-coml2api-readclassstg">ReadClassStg</a> function to read the CLSID that is saved in the object's storage. If you are writing a custom object handler for your object, you might want to simply delegate this method to the default handler implementation (see <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-olecreatedefaulthandler">OleCreateDefaultHandler</a>).</para>
			/// <para><h3><a id="URL_Moniker_Notes"></a><a id="url_moniker_notes"></a><a id="URL_MONIKER_NOTES"></a>URL Moniker Notes</h3> This method returns CLSID_StdURLMoniker.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersist-getclassid#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public unsafe void GetClassID(global::System.Guid* pClassID)
			{
				((delegate *unmanaged [Stdcall]<IPersist*,global::System.Guid* ,winmdroot.Foundation.HRESULT>)lpVtbl[3])((IPersist*)Unsafe.AsPointer(ref this), pClassID).ThrowOnFailure();
			}

			internal struct Vtbl
			{
				internal delegate *unmanaged [Stdcall]<IPersist*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT> QueryInterface_1;

				internal delegate *unmanaged [Stdcall]<IPersist*,uint> AddRef_2;

				internal delegate *unmanaged [Stdcall]<IPersist*,uint> Release_3;

				internal delegate *unmanaged [Stdcall]<IPersist*,global::System.Guid* ,winmdroot.Foundation.HRESULT> GetClassID_4;
			} 
			public static void PopulateVTable(Vtbl* vtable)
			{
				vtable->GetClassID_4 = &GetClassID;
			}

			private void** lpVtbl;

			/// <summary>The IID guid for this interface.</summary>
			/// <value>{0000010c-0000-0000-c000-000000000046}</value>
			internal static readonly Guid IID_Guid = new Guid(0x0000010C, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

			static ref readonly Guid IComIID.Guid			{
								[MethodImpl(MethodImplOptions.AggressiveInlining)]
get
				{
					ReadOnlySpan<byte> data = new byte[]					{
0x0C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46					};
					return ref Unsafe.As<byte,Guid>(ref MemoryMarshal.GetReference(data));
				}
			}
			[Guid("0000010C-0000-0000-C000-000000000046"),InterfaceType(ComInterfaceType.InterfaceIsIUnknown),ComImport()]
			[SupportedOSPlatform("windows5.0")]
			internal interface Interface
			{
				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT GetClassID(global::System.Guid* pClassID);
			}
		}

		[Guid("0000010B-0000-0000-C000-000000000046")]
		[SupportedOSPlatform("windows5.0")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal unsafe partial struct IPersistFile
			:IVTable<IPersistFile,IPersistFile.Vtbl>,IComIID		{
			/// <inheritdoc cref="QueryInterface(global::System.Guid*, void**)"/>
			internal unsafe winmdroot.Foundation.HRESULT QueryInterface(in global::System.Guid riid, out void* ppvObject)
			{
				fixed (void** ppvObjectLocal = &ppvObject)
				{
					fixed (global::System.Guid* riidLocal = &riid)
					{
						winmdroot.Foundation.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
						return __result;
					}
				}
			}

			public unsafe winmdroot.Foundation.HRESULT QueryInterface(global::System.Guid* riid, void** ppvObject)
			{
				return ((delegate *unmanaged [Stdcall]<IPersistFile*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT>)lpVtbl[0])((IPersistFile*)Unsafe.AsPointer(ref this), riid, ppvObject);
			}

			public uint AddRef()
			{
				return ((delegate *unmanaged [Stdcall]<IPersistFile*,uint>)lpVtbl[1])((IPersistFile*)Unsafe.AsPointer(ref this));
			}

			public uint Release()
			{
				return ((delegate *unmanaged [Stdcall]<IPersistFile*,uint>)lpVtbl[2])((IPersistFile*)Unsafe.AsPointer(ref this));
			}

			/// <inheritdoc cref="GetClassID(global::System.Guid*)"/>
			internal unsafe void GetClassID(out global::System.Guid pClassID)
			{
				fixed (global::System.Guid* pClassIDLocal = &pClassID)
				{
					this.GetClassID(pClassIDLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetClassID(IPersistFile* pThis, global::System.Guid* pClassID)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetClassID(pClassID);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			public unsafe void GetClassID(global::System.Guid* pClassID)
			{
				((delegate *unmanaged [Stdcall]<IPersistFile*,global::System.Guid* ,winmdroot.Foundation.HRESULT>)lpVtbl[3])((IPersistFile*)Unsafe.AsPointer(ref this), pClassID).ThrowOnFailure();
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT IsDirty(IPersistFile* pThis)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.IsDirty();
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Determines whether an object has changed since it was last saved to its current file.</summary>
			/// <returns>This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.</returns>
			/// <remarks>
			/// <para>Use this method to determine whether an object should be saved before closing it. The dirty flag for an object is conditionally cleared in the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersistfile-save">IPersistFile::Save</a> method. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> OLE does not call <b>IsDirty</b>. Applications would not call it unless they are also saving an object to a file. You should treat any error return codes as an indication that the object has changed. Unless this method explicitly returns S_FALSE, assume that the object must be saved. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> An object with no contained objects simply checks its dirty flag to return the appropriate result. A container with one or more contained objects must maintain an internal dirty flag that is set when any of its contained objects has changed since it was last saved. To do this, the container should maintain an advise sink by implementing the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-iadvisesink">IAdviseSink</a> interface. Then, the container can register each link or embedding for data change notifications with a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-dadvise">IDataObject::DAdvise</a>. Then, the container can set its internal dirty flag when it receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-iadvisesink-ondatachange">IAdviseSink::OnDataChange</a> notification. If the container does not register for data change notifications, the <b>IPersistFile::IsDirty</b> implementation would call <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststorage-isdirty">IPersistStorage::IsDirty</a> for each of its contained objects to determine whether they have changed. The container can clear its dirty flag whenever it is saved, as long as the file to which the object is saved is the current working file after the save. Therefore, the dirty flag would be cleared after a successful <b>Save</b> or <b>Save As</b> operation, but not after a <b>Save A Copy As . . .</b> operation.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersistfile-isdirty#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public winmdroot.Foundation.HRESULT IsDirty()
			{
				return ((delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.HRESULT>)lpVtbl[4])((IPersistFile*)Unsafe.AsPointer(ref this));
			}

			/// <inheritdoc cref="Load(winmdroot.Foundation.PCWSTR, winmdroot.System.Com.STGM)"/>
			internal unsafe void Load(string pszFileName, winmdroot.System.Com.STGM dwMode)
			{
				fixed (char* pszFileNameLocal = pszFileName)
				{
					this.Load(pszFileNameLocal, dwMode);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT Load(IPersistFile* pThis, winmdroot.Foundation.PCWSTR pszFileName, winmdroot.System.Com.STGM dwMode)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.Load(pszFileName, dwMode);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Opens the specified file and initializes an object from the file contents.</summary>
			/// <param name="pszFileName">The absolute path of the file to be opened.</param>
			/// <param name="dwMode">The access mode to be used when opening the file. Possible values are taken from the <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> enumeration. The method can treat this value as a suggestion, adding more restrictive permissions if necessary. If <i>dwMode</i> is 0, the implementation should open the file using whatever default permissions are used when a user opens the file.</param>
			/// <returns>
			/// <para>This method can return the following values. </para>
			/// <para>This doc was truncated.</para>
			/// </returns>
			/// <remarks>
			/// <para><b>IPersistFile::Load</b> loads the object from the specified file. This method is for initialization only and does not show the object to the end user. It is not equivalent to what occurs when a user selects the <b>File Open</b> command. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> The <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imoniker-bindtoobject">BindToObject</a> method in file monikers calls this method to load an object during a moniker binding operation (when a linked object is run). Typically, applications do not call this method directly. <h3><a id="Notes_to_Implementers"></a><a id="notes_to_implementers"></a><a id="NOTES_TO_IMPLEMENTERS"></a>Notes to Implementers</h3> Because the information needed to open a file varies greatly from one application to another, the object on which this method is implemented must also open the file specified by the <i>pszFileName</i> parameter. This differs from the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststorage-load">IPersistStorage::Load</a> and <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersiststream-load">IPersistStream::Load</a>, in which the caller opens the storage or stream and then passes an open storage or stream pointer to the loaded object. For an application that normally uses OLE compound files, your <b>IPersistFile::Load</b> implementation can simply call the <a href="https://docs.microsoft.com/windows/desktop/api/coml2api/nf-coml2api-stgopenstorage">StgOpenStorage</a> function to open the storage object in the specified file. Then, you can proceed with normal initialization. Applications that do not use storage objects can perform normal file-opening procedures. When the object has been loaded, your implementation should register the object in the running object table (see <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-register">IRunningObjectTable::Register</a>).</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersistfile-load#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public void Load(winmdroot.Foundation.PCWSTR pszFileName, winmdroot.System.Com.STGM dwMode)
			{
				((delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PCWSTR ,winmdroot.System.Com.STGM ,winmdroot.Foundation.HRESULT>)lpVtbl[5])((IPersistFile*)Unsafe.AsPointer(ref this), pszFileName, dwMode).ThrowOnFailure();
			}

			/// <inheritdoc cref="Save(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.BOOL)"/>
			internal unsafe void Save(string pszFileName, winmdroot.Foundation.BOOL fRemember)
			{
				fixed (char* pszFileNameLocal = pszFileName)
				{
					this.Save(pszFileNameLocal, fRemember);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT Save(IPersistFile* pThis, winmdroot.Foundation.PCWSTR pszFileName, winmdroot.Foundation.BOOL fRemember)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.Save(pszFileName, fRemember);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Saves a copy of the object to the specified file.</summary>
			/// <param name="pszFileName">The absolute path of the file to which the object should be saved. If <i>pszFileName</i> is <b>NULL</b>, the object should save its data to the current file, if there is one.</param>
			/// <param name="fRemember">Indicates whether the <i>pszFileName</i> parameter is to be used as the current working file. If <b>TRUE</b>, <i>pszFileName</i> becomes the current file and the object should clear its dirty flag after the save. If <b>FALSE</b>, this save operation is a <b>Save A Copy As ...</b> operation. In this case, the current file is unchanged and the object should not clear its dirty flag. If <i>pszFileName</i> is <b>NULL</b>, the implementation should ignore the <i>fRemember</i> flag.</param>
			/// <returns>If the object was successfully saved, the return value is S_OK. Otherwise, it is S_FALSE. This method can also return various storage errors.</returns>
			/// <remarks>
			/// <para>This method can be called to save an object to the specified file in one of three ways:</para>
			/// <para>The implementer must detect which type of save operation the caller is requesting. If the <i>pszFileName</i> parameter is <b>NULL</b>, a <b>Save</b> is being requested. If the <i>pszFileName</i> parameter is not <b>NULL</b>, use the value of the <i>fRemember</i> parameter to distinguish between a <b>Save As</b> and a <b>Save a Copy As</b>. In <b>Save</b> or <b>Save As</b> operations, <b>IPersistFile::Save</b> clears the internal dirty flag after the save and sends <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-iadvisesink-onsave">IAdviseSink::OnSave</a> notifications to any advisory connections (see also <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleadviseholder-sendonsave">IOleAdviseHolder::SendOnSave</a>). Also, in these operations, the object is in NoScribble mode until it receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersistfile-savecompleted">IPersistFile::SaveCompleted</a> call. In NoScribble mode, the object must not write to the file. In the <b>Save As</b> scenario, the implementation should also send <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-iadvisesink-onrename">IAdviseSink::OnRename</a> notifications to any advisory connections (see also <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-ioleadviseholder-sendonrename">IOleAdviseHolder::SendOnRename</a>). In the <b>Save a Copy As</b> scenario, the implementation does not clear the internal dirty flag after the save. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> OLE does not call <b>IPersistFile::Save</b>. Typically, applications would not call it unless they are saving an object to a file directly, which is generally left to the end-user.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersistfile-save#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public void Save(winmdroot.Foundation.PCWSTR pszFileName, winmdroot.Foundation.BOOL fRemember)
			{
				((delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.BOOL ,winmdroot.Foundation.HRESULT>)lpVtbl[6])((IPersistFile*)Unsafe.AsPointer(ref this), pszFileName, fRemember).ThrowOnFailure();
			}

			/// <inheritdoc cref="SaveCompleted(winmdroot.Foundation.PCWSTR)"/>
			internal unsafe void SaveCompleted(string pszFileName)
			{
				fixed (char* pszFileNameLocal = pszFileName)
				{
					this.SaveCompleted(pszFileNameLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SaveCompleted(IPersistFile* pThis, winmdroot.Foundation.PCWSTR pszFileName)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SaveCompleted(pszFileName);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Notifies the object that it can write to its file.</summary>
			/// <param name="pszFileName">The absolute path of the file where the object was saved previously.</param>
			/// <returns>This method always returns S_OK.</returns>
			/// <remarks>
			/// <para><b>SaveCompleted</b> is called when a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersistfile-save">IPersistFile::Save</a> is completed, and the file that was saved is now the current working file (having been saved with <b>Save</b> or <b>Save As</b> operations). The call to <b>Save</b> puts the object into NoScribble mode so it cannot write to its file. When <b>SaveCompleted</b> is called, the object reverts to Normal mode, in which it is free to write to its file. <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> OLE does not call the <b>SaveCompleted</b> method. Typically, applications would not call it unless they are saving objects directly to files, an operation which is generally left to the end-user.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersistfile-savecompleted#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public void SaveCompleted(winmdroot.Foundation.PCWSTR pszFileName)
			{
				((delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT>)lpVtbl[7])((IPersistFile*)Unsafe.AsPointer(ref this), pszFileName).ThrowOnFailure();
			}

			/// <inheritdoc cref="GetCurFile(winmdroot.Foundation.PWSTR*)"/>
			internal unsafe void GetCurFile(out winmdroot.Foundation.PWSTR ppszFileName)
			{
				fixed (winmdroot.Foundation.PWSTR* ppszFileNameLocal = &ppszFileName)
				{
					this.GetCurFile(ppszFileNameLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetCurFile(IPersistFile* pThis, winmdroot.Foundation.PWSTR* ppszFileName)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetCurFile(ppszFileName);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Retrieves the current name of the file associated with the object. If there is no current working file, this method retrieves the default save prompt for the object.</summary>
			/// <param name="ppszFileName">The path for the current file or the default file name prompt (such as *.txt). If an error occurs, <i>ppszFileName</i> is set to <b>NULL</b>.</param>
			/// <returns>
			/// <para>This method can return the following values. </para>
			/// <para>This doc was truncated.</para>
			/// </returns>
			/// <remarks>
			/// <para>This method allocates memory for the string returned in the <i>ppszFileName</i> parameter using the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imalloc-alloc">IMalloc::Alloc</a> method. The caller is responsible for calling the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-imalloc-free">IMalloc::Free</a> method to free the string. Both the caller and this method use the OLE task allocator provided by a call to <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetmalloc">CoGetMalloc</a>. The file name returned in <i>ppszFileName</i> is the name specified in a call to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersistfile-load">IPersistFile::Load</a> when the document was loaded; or in <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersistfile-savecompleted">IPersistFile::SaveCompleted</a> if the document was saved to a different file. If the object does not have a current working file, it should provide the default prompt that it would display in a <b>Save As</b> dialog box. For example, the default save prompt for a word processor object could be "*.txt". <h3><a id="Notes_to_Callers"></a><a id="notes_to_callers"></a><a id="NOTES_TO_CALLERS"></a>Notes to Callers</h3> OLE does not call the <b>GetCurFile</b> method. Applications would not call this method unless they are also calling the save methods of this interface. In saving the object, you can call this method before calling <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ipersistfile-save">IPersistFile::Save</a> to determine whether the object has an associated file. If this method returns S_OK, you can then call <b>IPersistFile::Save</b> with a <b>NULL</b> filename and a <b>TRUE</b> value for the <i>fRemember</i> parameter to tell the object to save itself to its current file. If this method returns S_FALSE, you can use the save prompt returned in the <i>ppszFileName</i> parameter to ask the end user to provide a file name. Then, you can call <b>IPersistFile::Save</b> with the file name that the user entered to perform a <b>Save As</b> operation.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/objidl/nf-objidl-ipersistfile-getcurfile#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public unsafe void GetCurFile(winmdroot.Foundation.PWSTR* ppszFileName)
			{
				((delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PWSTR* ,winmdroot.Foundation.HRESULT>)lpVtbl[8])((IPersistFile*)Unsafe.AsPointer(ref this), ppszFileName).ThrowOnFailure();
			}

			internal struct Vtbl
			{
				internal delegate *unmanaged [Stdcall]<IPersistFile*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT> QueryInterface_1;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,uint> AddRef_2;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,uint> Release_3;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,global::System.Guid* ,winmdroot.Foundation.HRESULT> GetClassID_4;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.HRESULT> IsDirty_5;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PCWSTR ,winmdroot.System.Com.STGM ,winmdroot.Foundation.HRESULT> Load_6;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.BOOL ,winmdroot.Foundation.HRESULT> Save_7;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT> SaveCompleted_8;

				internal delegate *unmanaged [Stdcall]<IPersistFile*,winmdroot.Foundation.PWSTR* ,winmdroot.Foundation.HRESULT> GetCurFile_9;
			} 
			public static void PopulateVTable(Vtbl* vtable)
			{
				vtable->GetClassID_4 = &GetClassID;
				vtable->IsDirty_5 = &IsDirty;
				vtable->Load_6 = &Load;
				vtable->Save_7 = &Save;
				vtable->SaveCompleted_8 = &SaveCompleted;
				vtable->GetCurFile_9 = &GetCurFile;
			}

			private void** lpVtbl;

			/// <summary>The IID guid for this interface.</summary>
			/// <value>{0000010b-0000-0000-c000-000000000046}</value>
			internal static readonly Guid IID_Guid = new Guid(0x0000010B, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

			static ref readonly Guid IComIID.Guid			{
								[MethodImpl(MethodImplOptions.AggressiveInlining)]
get
				{
					ReadOnlySpan<byte> data = new byte[]					{
0x0B,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46					};
					return ref Unsafe.As<byte,Guid>(ref MemoryMarshal.GetReference(data));
				}
			}
			[Guid("0000010B-0000-0000-C000-000000000046"),InterfaceType(ComInterfaceType.InterfaceIsIUnknown),ComImport()]
			[SupportedOSPlatform("windows5.0")]
			internal interface Interface
				:winmdroot.System.Com.IPersist.Interface			{
				[PreserveSig()]
				unsafe new winmdroot.Foundation.HRESULT GetClassID(global::System.Guid* pClassID);

								[PreserveSig()]
winmdroot.Foundation.HRESULT IsDirty();

								[PreserveSig()]
winmdroot.Foundation.HRESULT Load(winmdroot.Foundation.PCWSTR pszFileName, winmdroot.System.Com.STGM dwMode);

								[PreserveSig()]
winmdroot.Foundation.HRESULT Save(winmdroot.Foundation.PCWSTR pszFileName, winmdroot.Foundation.BOOL fRemember);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SaveCompleted(winmdroot.Foundation.PCWSTR pszFileName);

				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT GetCurFile(winmdroot.Foundation.PWSTR* ppszFileName);
			}
		}

		/// <summary>Values that are used in activation calls to indicate the execution contexts in which an object is to be run.</summary>
		/// <remarks>
		/// <para>Values from the <b>CLSCTX</b> enumeration are used in activation calls (<a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance">CoCreateInstance</a>, <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstanceex">CoCreateInstanceEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject">CoGetClassObject</a>, and so on) to indicate the preferred execution contexts (in-process, local, or remote) in which an object is to be run. They are also used in calls to <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject">CoRegisterClassObject</a> to indicate the set of execution contexts in which a class object is to be made available for requests to construct instances (<b>IClassFactory::CreateInstance</b>). To indicate that more than one context is acceptable, you can combine multiple values with Boolean ORs. The contexts are tried in the order in which they are listed.</para>
		/// <para>Given a set of <b>CLSCTX</b> flags, the execution context to be used depends on the availability of registered class codes and other parameters according to the following algorithm.</para>
		/// <para></para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[Flags]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal enum CLSCTX : uint
		{
			/// <summary>The code that creates and manages objects of this class is a DLL that runs in the same process as the caller of the function specifying the class context.</summary>
			CLSCTX_INPROC_SERVER = 0x00000001,
			/// <summary>The code that manages objects of this class is an in-process handler. This is a DLL that runs in the client process and implements client-side structures of this class when instances of the class are accessed remotely.</summary>
			CLSCTX_INPROC_HANDLER = 0x00000002,
			/// <summary>The EXE code that creates and manages objects of this class runs on same machine but is loaded in a separate process space.</summary>
			CLSCTX_LOCAL_SERVER = 0x00000004,
			/// <summary>Obsolete.</summary>
			CLSCTX_INPROC_SERVER16 = 0x00000008,
			/// <summary>A remote context. The <a href="https://docs.microsoft.com/windows/desktop/com/localserver32">LocalServer32</a> or <a href="https://docs.microsoft.com/windows/desktop/com/localservice">LocalService</a> code that creates and manages objects of this class is run on a different computer.</summary>
			CLSCTX_REMOTE_SERVER = 0x00000010,
			/// <summary>Obsolete.</summary>
			CLSCTX_INPROC_HANDLER16 = 0x00000020,
			/// <summary>Reserved.</summary>
			CLSCTX_RESERVED1 = 0x00000040,
			/// <summary>Reserved.</summary>
			CLSCTX_RESERVED2 = 0x00000080,
			/// <summary>Reserved.</summary>
			CLSCTX_RESERVED3 = 0x00000100,
			/// <summary>Reserved.</summary>
			CLSCTX_RESERVED4 = 0x00000200,
			/// <summary>Disables the downloading of code from the directory service or the Internet. This flag cannot be set at the same time as CLSCTX_ENABLE_CODE_DOWNLOAD.</summary>
			CLSCTX_NO_CODE_DOWNLOAD = 0x00000400,
			/// <summary>Reserved.</summary>
			CLSCTX_RESERVED5 = 0x00000800,
			/// <summary>Specify if you want the activation to fail if it uses custom marshalling.</summary>
			CLSCTX_NO_CUSTOM_MARSHAL = 0x00001000,
			/// <summary>Enables the downloading of code from the directory service or the Internet. This flag cannot be set at the same time as CLSCTX_NO_CODE_DOWNLOAD.</summary>
			CLSCTX_ENABLE_CODE_DOWNLOAD = 0x00002000,
			/// <summary>
			/// <para>The CLSCTX_NO_FAILURE_LOG can be used to override the logging of failures in <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstanceex">CoCreateInstanceEx</a>. If the ActivationFailureLoggingLevel is created, the following values can determine the status of event logging: </para>
			/// <para>This doc was truncated.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			CLSCTX_NO_FAILURE_LOG = 0x00004000,
			/// <summary>
			/// <para>Disables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same time as CLSCTX_ENABLE_AAA. Any activation where a server process would be launched under the caller's identity is known as an activate-as-activator (AAA) activation. Disabling AAA activations allows an application that runs under a privileged account (such as LocalSystem) to help prevent its identity from being used to launch untrusted components. Library applications that use activation calls should always set this flag during those calls. This helps prevent the library application from being used in an escalation-of-privilege security attack. This is the only way to disable AAA activations in a library application because the EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration is applied only to the server process and not to the library application. <b>Windows 2000:  </b>This flag is not supported.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			CLSCTX_DISABLE_AAA = 0x00008000,
			/// <summary>
			/// <para>Enables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same time as CLSCTX_DISABLE_AAA. Any activation where a server process would be launched under the caller's identity is known as an activate-as-activator (AAA) activation. Enabling this flag allows an application to transfer its identity to an activated component. <b>Windows 2000:  </b>This flag is not supported.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			CLSCTX_ENABLE_AAA = 0x00010000,
			/// <summary>Begin this activation from the default context of the current apartment.</summary>
			CLSCTX_FROM_DEFAULT_CONTEXT = 0x00020000,
			/// <summary></summary>
			CLSCTX_ACTIVATE_X86_SERVER = 0x00040000,
			/// <summary>Activate or connect to a 32-bit version of the server; fail if one is not registered.</summary>
			CLSCTX_ACTIVATE_32_BIT_SERVER = 0x00040000,
			/// <summary>Activate or connect to a 64 bit version of the server; fail if one is not registered.</summary>
			CLSCTX_ACTIVATE_64_BIT_SERVER = 0x00080000,
			/// <summary>
			/// <para>When this flag is specified, COM uses the impersonation token of the thread, if one is present, for the activation request made by the thread. When this flag is not specified or if the thread does not have an impersonation token, COM uses the process token of the thread's process for the activation request made by the thread.</para>
			/// <para><b>Windows Vista or later:  </b>This flag is supported.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			CLSCTX_ENABLE_CLOAKING = 0x00100000,
			/// <summary>
			/// <para>Indicates activation is for an app container.</para>
			/// <para><div class="alert"><b>Note</b>  This flag is reserved for internal use and is not intended to be used directly from your code.</div> <div> </div></para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			CLSCTX_APPCONTAINER = 0x00400000,
			/// <summary>
			/// <para>Specify this flag for Interactive User activation behavior for As-Activator servers. A strongly named Medium IL Windows Store app can use this flag to launch an "As Activator" COM server without a strong name. Also, you can use this flag to bind to a running instance of the COM server that's launched by a desktop application. The client must be Medium IL, it must be strongly named, which means that it has a SysAppID in the client token, it can't be in session 0,  and it must have the same user as the session ID's user in the client token. If  the server is out-of-process and "As Activator", it launches the server with the token of the client token's session user. This token won't be strongly named. If the server is out-of-process and RunAs "Interactive User", this flag has no effect. If the server is out-of-process and is any other RunAs type, the activation fails. This flag has no effect for in-process servers. Off-machine activations fail when they use this flag.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			CLSCTX_ACTIVATE_AAA_AS_IU = 0x00800000,
			/// <summary></summary>
			CLSCTX_RESERVED6 = 0x01000000,
			/// <summary></summary>
			CLSCTX_ACTIVATE_ARM32_SERVER = 0x02000000,
			CLSCTX_ALLOW_LOWER_TRUST_REGISTRATION = 0x04000000,
			/// <summary>
			/// <para>Used for loading Proxy/Stub DLLs.</para>
			/// <para><div class="alert"><b>Note</b>  This flag is reserved for internal use and is not intended to be used directly from your code.</div> <div> </div></para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ne-wtypesbase-clsctx#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			CLSCTX_PS_DLL = 0x80000000,
			CLSCTX_ALL = 0x00000017,
			CLSCTX_SERVER = 0x00000015,
		}
	}

	namespace Storage.FileSystem
	{
		/// <summary>Contains information about the file that is found by the FindFirstFile, FindFirstFileEx, or FindNextFile function. (Unicode)</summary>
		/// <remarks>
		/// <para>If a file has a long file name, the complete name appears in the <b>cFileName</b> member, and the 8.3 format truncated version of the name appears in the <b>cAlternateFileName</b> member. Otherwise, <b>cAlternateFileName</b> is empty. If the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a> function was called with a value of <b>FindExInfoBasic</b> in the <i>fInfoLevelId</i> parameter, the <b>cAlternateFileName</b> member will always contain a <b>NULL</b> string value. This remains true for all subsequent calls to the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> function. As an alternative method of retrieving the 8.3 format version of a file name, you can use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getshortpathnamew">GetShortPathName</a> function. For more information about file names, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>. Not all file systems can record creation and last access times, and not all file systems record them in the same manner. For example, on the FAT file system, create time has a resolution of 10 milliseconds, write time has a resolution of 2 seconds, and access time has a resolution of 1 day. The NTFS file system delays updates to the last access time for a file by up to 1 hour after the last access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/file-times">File Times</a>.</para>
		/// <para>> [!NOTE] > The minwinbase.h header defines WIN32_FIND_DATA as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal partial struct WIN32_FIND_DATAW
		{
			/// <summary>
			/// <para>The file attributes of a file. For possible values and their descriptions, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. The <b>FILE_ATTRIBUTE_SPARSE_FILE</b> attribute on the file is set if any of the streams of the file have ever been sparse.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal uint dwFileAttributes;

			/// <summary>
			/// <para>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies when a file or directory was created. If the underlying file system does not support creation time, this member is zero.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal global::System.Runtime.InteropServices.ComTypes.FILETIME ftCreationTime;

			/// <summary>
			/// <para>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure. For a file, the structure specifies when the file was last read from, written to, or for executable files, run. For a directory, the structure specifies when the directory is created. If the underlying file system does not support last access time, this member is zero. On the FAT file system, the specified date for both files and directories is correct, but the time of day is always set to midnight.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal global::System.Runtime.InteropServices.ComTypes.FILETIME ftLastAccessTime;

			/// <summary>
			/// <para>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure. For a file, the structure specifies when the file was last written to, truncated, or overwritten, for example, when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> or <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a> are used. The date and time are not updated when file attributes or security descriptors are changed. For a directory, the structure specifies when the directory is created. If the underlying file system does not support last write time, this member is zero.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal global::System.Runtime.InteropServices.ComTypes.FILETIME ftLastWriteTime;

			/// <summary>
			/// <para>The high-order <b>DWORD</b> value of the file size, in bytes. This value is zero unless the file size is greater than <b>MAXDWORD</b>. The size of the file is equal to (<b>nFileSizeHigh</b> * (<b>MAXDWORD</b>+1)) + <b>nFileSizeLow</b>.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal uint nFileSizeHigh;

			/// <summary>The low-order <b>DWORD</b> value of the file size, in bytes.</summary>
			internal uint nFileSizeLow;

			/// <summary>
			/// <para>If the <b>dwFileAttributes</b> member includes the <b>FILE_ATTRIBUTE_REPARSE_POINT</b> attribute, this member specifies the reparse point tag. Otherwise, this value is undefined and should not be used. For more information see <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-point-tags">Reparse Point Tags</a>.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal uint dwReserved0;

			/// <summary>Reserved for future use.</summary>
			internal uint dwReserved1;

			/// <summary>The name of the file.</summary>
			internal winmdroot.__char_260 cFileName;

			/// <summary>
			/// <para>An alternative name for the file. This name is in the classic 8.3 file name format.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataw#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal winmdroot.__char_14 cAlternateFileName;
		}
	}

	namespace UI.Shell.Common
	{
		/// <summary>Defines an item identifier.</summary>
		/// <remarks>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-shitemid">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal partial struct SHITEMID
		{
			/// <summary>
			/// <para>Type: <b>USHORT</b> The size of identifier, in bytes, including <b>cb</b> itself.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-shitemid#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal ushort cb;

			/// <summary>
			/// <para>Type: <b>BYTE[1]</b> A variable-length item identifier.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-shitemid#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal winmdroot.__byte_1 abID;
		}

		/// <summary>Contains a list of item identifiers.</summary>
		/// <remarks>
		/// <para>A pointer to this structure, called a <i>PIDL</i>, is used to identify objects in the Shell namespace.  For more information about pointers to item identifier lists (PIDLs) and item identifiers, see <a href="https://docs.microsoft.com/windows/desktop/shell/namespace-intro">Introduction to the Shell Namespace</a>. <h3><a id="ITEMIDLIST_Strict_Types"></a><a id="itemidlist_strict_types"></a><a id="ITEMIDLIST_STRICT_TYPES"></a>ITEMIDLIST Strict Types</h3> As of Windows Vista, several forms of <b>ITEMIDLIST</b> are available as data types. The three main types are:</para>
		/// <para></para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-itemidlist#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal partial struct ITEMIDLIST
		{
			/// <summary>
			/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a></b> A list of item identifiers.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shtypes/ns-shtypes-itemidlist#members">Read more on docs.microsoft.com</see>.</para>
			/// </summary>
			internal winmdroot.UI.Shell.Common.SHITEMID mkid;
		}
	}

	namespace UI.WindowsAndMessaging
	{
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal enum SHOW_WINDOW_CMD
		{
			SW_HIDE = 0,
			SW_SHOWNORMAL = 1,
			SW_NORMAL = 1,
			SW_SHOWMINIMIZED = 2,
			SW_SHOWMAXIMIZED = 3,
			SW_MAXIMIZE = 3,
			SW_SHOWNOACTIVATE = 4,
			SW_SHOW = 5,
			SW_MINIMIZE = 6,
			SW_SHOWMINNOACTIVE = 7,
			SW_SHOWNA = 8,
			SW_RESTORE = 9,
			SW_SHOWDEFAULT = 10,
			SW_FORCEMINIMIZE = 11,
			SW_MAX = 11,
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct HICON
			: IEquatable<HICON>
		{
			internal readonly IntPtr Value;

			internal HICON(IntPtr value) => this.Value = value;

			internal static HICON Null => default;

			internal bool IsNull => Value == default;

			public static implicit operator IntPtr(HICON value) => value.Value;

			public static explicit operator HICON(IntPtr value) => new HICON(value);

			public static bool operator ==(HICON left, HICON right) => left.Value == right.Value;

			public static bool operator !=(HICON left, HICON right) => !(left == right);

			public bool Equals(HICON other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is HICON other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();

			public override string ToString() => $"0x{this.Value:x}";
		}

		[DebuggerDisplay("{Value}")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal readonly partial struct HCURSOR
			: IEquatable<HCURSOR>
		{
			internal readonly IntPtr Value;

			internal HCURSOR(IntPtr value) => this.Value = value;

			internal static HCURSOR Null => default;

			internal bool IsNull => Value == default;

			public static implicit operator IntPtr(HCURSOR value) => value.Value;

			public static explicit operator HCURSOR(IntPtr value) => new HCURSOR(value);

			public static bool operator ==(HCURSOR left, HCURSOR right) => left.Value == right.Value;

			public static bool operator !=(HCURSOR left, HCURSOR right) => !(left == right);

			public bool Equals(HCURSOR other) => this.Value == other.Value;

			public override bool Equals(object obj) => obj is HCURSOR other && this.Equals(other);

			public override int GetHashCode() => this.Value.GetHashCode();

			public override string ToString() => $"0x{this.Value:x}";

			public static implicit operator HICON(HCURSOR value) => new HICON(value.Value);
		}
	}

	namespace UI.Shell
	{
		[Guid("000214F9-0000-0000-C000-000000000046")]
		[SupportedOSPlatform("windows5.1.2600")]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal unsafe partial struct IShellLinkW
			:IVTable<IShellLinkW,IShellLinkW.Vtbl>,IComIID		{
			/// <inheritdoc cref="QueryInterface(global::System.Guid*, void**)"/>
			internal unsafe winmdroot.Foundation.HRESULT QueryInterface(in global::System.Guid riid, out void* ppvObject)
			{
				fixed (void** ppvObjectLocal = &ppvObject)
				{
					fixed (global::System.Guid* riidLocal = &riid)
					{
						winmdroot.Foundation.HRESULT __result = this.QueryInterface(riidLocal, ppvObjectLocal);
						return __result;
					}
				}
			}

			public unsafe winmdroot.Foundation.HRESULT QueryInterface(global::System.Guid* riid, void** ppvObject)
			{
				return ((delegate *unmanaged [Stdcall]<IShellLinkW*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT>)lpVtbl[0])((IShellLinkW*)Unsafe.AsPointer(ref this), riid, ppvObject);
			}

			public uint AddRef()
			{
				return ((delegate *unmanaged [Stdcall]<IShellLinkW*,uint>)lpVtbl[1])((IShellLinkW*)Unsafe.AsPointer(ref this));
			}

			public uint Release()
			{
				return ((delegate *unmanaged [Stdcall]<IShellLinkW*,uint>)lpVtbl[2])((IShellLinkW*)Unsafe.AsPointer(ref this));
			}

			/// <inheritdoc cref="GetPath(winmdroot.Foundation.PWSTR, int, winmdroot.Storage.FileSystem.WIN32_FIND_DATAW*, uint)"/>
			internal unsafe void GetPath(winmdroot.Foundation.PWSTR pszFile, int cch, ref winmdroot.Storage.FileSystem.WIN32_FIND_DATAW pfd, uint fFlags)
			{
				fixed (winmdroot.Storage.FileSystem.WIN32_FIND_DATAW* pfdLocal = &pfd)
				{
					this.GetPath(pszFile, cch, pfdLocal, fFlags);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetPath(IShellLinkW* pThis, winmdroot.Foundation.PWSTR pszFile, int cch, winmdroot.Storage.FileSystem.WIN32_FIND_DATAW* pfd, uint fFlags)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetPath(pszFile, cch, pfd, fFlags);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the path and file name of the target of a Shell link object. (Unicode)</summary>
			/// <param name="pszFile">
			/// <para>Type: <b>LPTSTR</b> The address of a buffer that receives the path and file name of the target of the Shell link object.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getpath#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="cch">
			/// <para>Type: <b>int</b> The size, in characters, of the buffer pointed to by the <i>pszFile</i> parameter, including the terminating null character. The maximum path size that can be returned is MAX_PATH. This parameter is commonly set by calling ARRAYSIZE(pszFile). The ARRAYSIZE macro is defined in Winnt.h.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getpath#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="pfd">
			/// <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a>*</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that receives information about the target of the Shell link object. If this parameter is <b>NULL</b>, then no additional information is returned.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getpath#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="fFlags">Type: <b>DWORD</b></param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> Returns <b>S_OK</b> if the operation is successful and a valid path is retrieved. If the operation is successful but no path is retrieved, it returns <b>S_FALSE</b> and <i>pszFile</i> will be empty. Otherwise, it returns one of the standard HRESULT error values.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getpath">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public unsafe void GetPath(winmdroot.Foundation.PWSTR pszFile, int cch, winmdroot.Storage.FileSystem.WIN32_FIND_DATAW* pfd, uint fFlags)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Storage.FileSystem.WIN32_FIND_DATAW* ,uint ,winmdroot.Foundation.HRESULT>)lpVtbl[3])((IShellLinkW*)Unsafe.AsPointer(ref this), pszFile, cch, pfd, fFlags).ThrowOnFailure();
			}

			/// <inheritdoc cref="GetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST**)"/>
			internal unsafe void GetIDList(out winmdroot.UI.Shell.Common.ITEMIDLIST* ppidl)
			{
				fixed (winmdroot.UI.Shell.Common.ITEMIDLIST** ppidlLocal = &ppidl)
				{
					this.GetIDList(ppidlLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetIDList(IShellLinkW* pThis, winmdroot.UI.Shell.Common.ITEMIDLIST** ppidl)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetIDList(ppidl);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the list of item identifiers for the target of a Shell link object. (Unicode)</summary>
			/// <param name="ppidl">
			/// <para>Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns, contains the address of a PIDL.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getidlist#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> Returns S_OK if the operation is successful and one or more valid PIDLs is retrieved. If the operation is successful but no PIDLs are retrieved, it returns S_FALSE with <i>ppidl</i> set to <b>NULL</b>. Otherwise, it returns a standard error value.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getidlist">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public unsafe void GetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST** ppidl)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.Shell.Common.ITEMIDLIST** ,winmdroot.Foundation.HRESULT>)lpVtbl[4])((IShellLinkW*)Unsafe.AsPointer(ref this), ppidl).ThrowOnFailure();
			}

			/// <inheritdoc cref="SetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST*)"/>
			internal unsafe void SetIDList(in winmdroot.UI.Shell.Common.ITEMIDLIST pidl)
			{
				fixed (winmdroot.UI.Shell.Common.ITEMIDLIST* pidlLocal = &pidl)
				{
					this.SetIDList(pidlLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetIDList(IShellLinkW* pThis, winmdroot.UI.Shell.Common.ITEMIDLIST* pidl)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetIDList(pidl);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the pointer to an item identifier list (PIDL) for a Shell link object. (Unicode)</summary>
			/// <param name="pidl">
			/// <para>Type: <b>PCIDLIST_ABSOLUTE</b> The object's fully qualified PIDL.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setidlist#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>This method is useful when an application needs to set a Shell link to an object that is not a file, such as a Control Panel application, a printer, or another computer.</remarks>
			public unsafe void SetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST* pidl)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.Shell.Common.ITEMIDLIST* ,winmdroot.Foundation.HRESULT>)lpVtbl[5])((IShellLinkW*)Unsafe.AsPointer(ref this), pidl).ThrowOnFailure();
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetDescription(IShellLinkW* pThis, winmdroot.Foundation.PWSTR pszName, int cch)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetDescription(pszName, cch);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the description string for a Shell link object. (Unicode)</summary>
			/// <param name="pszName">
			/// <para>Type: <b>LPTSTR</b> A pointer to the buffer that receives the description string.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getdescription#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="cch">
			/// <para>Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszName</i> parameter.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getdescription#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>For Windows 2000 or later, the string returned to <i>pszName</i> has a maximum length of INFOTIPSIZE. For systems prior to Windows 2000, the size of the string is limited by MAX_PATH.</remarks>
			public void GetDescription(winmdroot.Foundation.PWSTR pszName, int cch)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Foundation.HRESULT>)lpVtbl[6])((IShellLinkW*)Unsafe.AsPointer(ref this), pszName, cch).ThrowOnFailure();
			}

			/// <inheritdoc cref="SetDescription(winmdroot.Foundation.PCWSTR)"/>
			internal unsafe void SetDescription(string pszName)
			{
				fixed (char* pszNameLocal = pszName)
				{
					this.SetDescription(pszNameLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetDescription(IShellLinkW* pThis, winmdroot.Foundation.PCWSTR pszName)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetDescription(pszName);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the description for a Shell link object. The description can be any application-defined string. (Unicode)</summary>
			/// <param name="pszName">
			/// <para>Type: <b>LPCTSTR</b> A pointer to a buffer containing the new description string.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setdescription#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>For Windows 2000 or later, the string specified by <i>pszName</i> must be no larger than INFOTIPSIZE. For systems prior to Windows 2000, the size of the string is limited by MAX_PATH.</remarks>
			public void SetDescription(winmdroot.Foundation.PCWSTR pszName)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT>)lpVtbl[7])((IShellLinkW*)Unsafe.AsPointer(ref this), pszName).ThrowOnFailure();
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetWorkingDirectory(IShellLinkW* pThis, winmdroot.Foundation.PWSTR pszDir, int cch)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetWorkingDirectory(pszDir, cch);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the name of the working directory for a Shell link object. (Unicode)</summary>
			/// <param name="pszDir">
			/// <para>Type: <b>LPTSTR</b> The address of a buffer that receives the name of the working directory.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getworkingdirectory#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="cch">
			/// <para>Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszDir</i> parameter. The name of the working directory is truncated if it is longer than the maximum specified by this parameter.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getworkingdirectory#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getworkingdirectory">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public void GetWorkingDirectory(winmdroot.Foundation.PWSTR pszDir, int cch)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Foundation.HRESULT>)lpVtbl[8])((IShellLinkW*)Unsafe.AsPointer(ref this), pszDir, cch).ThrowOnFailure();
			}

			/// <inheritdoc cref="SetWorkingDirectory(winmdroot.Foundation.PCWSTR)"/>
			internal unsafe void SetWorkingDirectory(string pszDir)
			{
				fixed (char* pszDirLocal = pszDir)
				{
					this.SetWorkingDirectory(pszDirLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetWorkingDirectory(IShellLinkW* pThis, winmdroot.Foundation.PCWSTR pszDir)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetWorkingDirectory(pszDir);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the name of the working directory for a Shell link object. (Unicode)</summary>
			/// <param name="pszDir">
			/// <para>Type: <b>LPCTSTR</b> The address of a buffer that contains the name of the new working directory.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setworkingdirectory#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>The working directory is optional unless the target requires a working directory. For example, if an application creates a Shell link to a Microsoft Word document that uses a template residing in a different directory, the application would use this method to set the working directory.</remarks>
			public void SetWorkingDirectory(winmdroot.Foundation.PCWSTR pszDir)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT>)lpVtbl[9])((IShellLinkW*)Unsafe.AsPointer(ref this), pszDir).ThrowOnFailure();
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetArguments(IShellLinkW* pThis, winmdroot.Foundation.PWSTR pszArgs, int cch)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetArguments(pszArgs, cch);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the command-line arguments associated with a Shell link object. (Unicode)</summary>
			/// <param name="pszArgs">
			/// <para>Type: <b>LPTSTR</b> A pointer to the buffer that, when this method returns successfully, receives the command-line arguments.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getarguments#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="cch">
			/// <para>Type: <b>int</b> The maximum number of characters that can be copied to the buffer supplied by the <i>pszArgs</i> parameter. In the case of a Unicode string, there is no limitation on maximum string length. In the case of an ANSI string, the maximum length of the returned string varies depending on the version of Windows—MAX_PATH prior to Windows 2000 and INFOTIPSIZE (defined in Commctrl.h) in Windows 2000 and later.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getarguments#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>In Windows 7 and later, it is recommended that you retrieve argument strings though <a href="https://docs.microsoft.com/windows/desktop/api/propsys/nn-propsys-ipropertystore">IPropertyStore</a> (using the <a href="https://docs.microsoft.com/windows/desktop/properties/props-system-link-arguments">PKEY_Link_Arguments</a> value) rather than this method, which can silently truncate the string if the provided buffer is not large enough. <b>IPropertyStore</b> allocates a string of the correct size.</remarks>
			public void GetArguments(winmdroot.Foundation.PWSTR pszArgs, int cch)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Foundation.HRESULT>)lpVtbl[10])((IShellLinkW*)Unsafe.AsPointer(ref this), pszArgs, cch).ThrowOnFailure();
			}

			/// <inheritdoc cref="SetArguments(winmdroot.Foundation.PCWSTR)"/>
			internal unsafe void SetArguments(string pszArgs)
			{
				fixed (char* pszArgsLocal = pszArgs)
				{
					this.SetArguments(pszArgsLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetArguments(IShellLinkW* pThis, winmdroot.Foundation.PCWSTR pszArgs)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetArguments(pszArgs);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the command-line arguments for a Shell link object. (Unicode)</summary>
			/// <param name="pszArgs">
			/// <para>Type: <b>LPCTSTR</b> A pointer to a buffer that contains the new command-line arguments. In the case of a Unicode string, there is no limitation on maximum string length. In the case of an ANSI string, the maximum length of the returned string varies depending on the version of Windows—MAX_PATH prior to Windows 2000 and INFOTIPSIZE (defined in Commctrl.h) in Windows 2000 and later.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setarguments#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>This method is useful when creating a link to an application that takes special flags as arguments, such as a compiler.</remarks>
			public void SetArguments(winmdroot.Foundation.PCWSTR pszArgs)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT>)lpVtbl[11])((IShellLinkW*)Unsafe.AsPointer(ref this), pszArgs).ThrowOnFailure();
			}

			/// <inheritdoc cref="GetHotkey(ushort*)"/>
			internal unsafe void GetHotkey(out ushort pwHotkey)
			{
				fixed (ushort* pwHotkeyLocal = &pwHotkey)
				{
					this.GetHotkey(pwHotkeyLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetHotkey(IShellLinkW* pThis, ushort* pwHotkey)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetHotkey(pwHotkey);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the keyboard shortcut (hot key) for a Shell link object. (Unicode)</summary>
			/// <param name="pwHotkey">Type: <b>WORD*</b></param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-gethotkey">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public unsafe void GetHotkey(ushort* pwHotkey)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,ushort* ,winmdroot.Foundation.HRESULT>)lpVtbl[12])((IShellLinkW*)Unsafe.AsPointer(ref this), pwHotkey).ThrowOnFailure();
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetHotkey(IShellLinkW* pThis, ushort wHotkey)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetHotkey(wHotkey);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets a keyboard shortcut (hot key) for a Shell link object. (Unicode)</summary>
			/// <param name="wHotkey">
			/// <para>Type: <b>WORD</b> The new keyboard shortcut. The virtual key code is in the low-order byte, and the modifier flags are in the high-order byte. The modifier flags can be a combination of the values specified in the description of the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishelllinka-gethotkey">IShellLink::GetHotkey</a> method.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-sethotkey#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>Setting a keyboard shortcut allows the user to activate the object by pressing a particular combination of keys.</remarks>
			public void SetHotkey(ushort wHotkey)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,ushort ,winmdroot.Foundation.HRESULT>)lpVtbl[13])((IShellLinkW*)Unsafe.AsPointer(ref this), wHotkey).ThrowOnFailure();
			}

			/// <inheritdoc cref="GetShowCmd(winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD*)"/>
			internal unsafe void GetShowCmd(out winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD piShowCmd)
			{
				fixed (winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD* piShowCmdLocal = &piShowCmd)
				{
					this.GetShowCmd(piShowCmdLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetShowCmd(IShellLinkW* pThis, winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD* piShowCmd)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetShowCmd(piShowCmd);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the show command for a Shell link object. (Unicode)</summary>
			/// <param name="piShowCmd">
			/// <para>Type: <b>int*</b> A pointer to the command. The following commands are supported.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-getshowcmd#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>The show command is used to set the initial show state of the corresponding object. This is one of the SW_xxx values described in <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a>.</remarks>
			public unsafe void GetShowCmd(winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD* piShowCmd)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD* ,winmdroot.Foundation.HRESULT>)lpVtbl[14])((IShellLinkW*)Unsafe.AsPointer(ref this), piShowCmd).ThrowOnFailure();
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetShowCmd(IShellLinkW* pThis, winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD iShowCmd)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetShowCmd(iShowCmd);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the show command for a Shell link object. The show command sets the initial show state of the window. (Unicode)</summary>
			/// <param name="iShowCmd">
			/// <para>Type: <b>int</b> Command. <b>SetShowCmd</b> accepts one of the following <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> commands.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setshowcmd#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setshowcmd">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public void SetShowCmd(winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD iShowCmd)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD ,winmdroot.Foundation.HRESULT>)lpVtbl[15])((IShellLinkW*)Unsafe.AsPointer(ref this), iShowCmd).ThrowOnFailure();
			}

			/// <inheritdoc cref="GetIconLocation(winmdroot.Foundation.PWSTR, int, int*)"/>
			internal unsafe void GetIconLocation(winmdroot.Foundation.PWSTR pszIconPath, int cch, out int piIcon)
			{
				fixed (int* piIconLocal = &piIcon)
				{
					this.GetIconLocation(pszIconPath, cch, piIconLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT GetIconLocation(IShellLinkW* pThis, winmdroot.Foundation.PWSTR pszIconPath, int cch, int* piIcon)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.GetIconLocation(pszIconPath, cch, piIcon);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Gets the location (path and index) of the icon for a Shell link object. (Unicode)</summary>
			/// <param name="pszIconPath">
			/// <para>Type: <b>LPTSTR</b> The address of a buffer that receives the path of the file containing the icon.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-geticonlocation#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="cch">
			/// <para>Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszIconPath</i> parameter.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-geticonlocation#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="piIcon">
			/// <para>Type: <b>int*</b> The address of a value that receives the index of the icon.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-geticonlocation#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-geticonlocation">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public unsafe void GetIconLocation(winmdroot.Foundation.PWSTR pszIconPath, int cch, int* piIcon)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,int* ,winmdroot.Foundation.HRESULT>)lpVtbl[16])((IShellLinkW*)Unsafe.AsPointer(ref this), pszIconPath, cch, piIcon).ThrowOnFailure();
			}

			/// <inheritdoc cref="SetIconLocation(winmdroot.Foundation.PCWSTR, int)"/>
			internal unsafe void SetIconLocation(string pszIconPath, int iIcon)
			{
				fixed (char* pszIconPathLocal = pszIconPath)
				{
					this.SetIconLocation(pszIconPathLocal, iIcon);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetIconLocation(IShellLinkW* pThis, winmdroot.Foundation.PCWSTR pszIconPath, int iIcon)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetIconLocation(pszIconPath, iIcon);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the location (path and index) of the icon for a Shell link object. (Unicode)</summary>
			/// <param name="pszIconPath">
			/// <para>Type: <b>LPCTSTR</b> The address of a buffer to contain the path of the file containing the icon.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-seticonlocation#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="iIcon">
			/// <para>Type: <b>int</b> The index of the icon.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-seticonlocation#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-seticonlocation">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public void SetIconLocation(winmdroot.Foundation.PCWSTR pszIconPath, int iIcon)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,int ,winmdroot.Foundation.HRESULT>)lpVtbl[17])((IShellLinkW*)Unsafe.AsPointer(ref this), pszIconPath, iIcon).ThrowOnFailure();
			}

			/// <inheritdoc cref="SetRelativePath(winmdroot.Foundation.PCWSTR, uint)"/>
			internal unsafe void SetRelativePath(string pszPathRel, uint dwReserved)
			{
				fixed (char* pszPathRelLocal = pszPathRel)
				{
					this.SetRelativePath(pszPathRelLocal, dwReserved);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetRelativePath(IShellLinkW* pThis, winmdroot.Foundation.PCWSTR pszPathRel, uint dwReserved)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetRelativePath(pszPathRel, dwReserved);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the relative path to the Shell link object. (Unicode)</summary>
			/// <param name="pszPathRel">
			/// <para>Type: <b>LPCTSTR</b> The address of a buffer that contains the fully-qualified path of the shortcut file, relative to which the shortcut resolution should be performed. It should be a file name, not a folder name.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setrelativepath#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="dwReserved">
			/// <para>Type: <b>DWORD</b> Reserved. Set this parameter to zero.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setrelativepath#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>Clients commonly define a relative link when it may be moved along with its target, causing the absolute path to become invalid. The <b>SetRelativePath</b> method can be used to help the link resolution process find its target based on a common path prefix between the target and the relative path. To assist in the resolution process, clients should set the relative path as part of the link creation process.</remarks>
			public void SetRelativePath(winmdroot.Foundation.PCWSTR pszPathRel, uint dwReserved)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,uint ,winmdroot.Foundation.HRESULT>)lpVtbl[18])((IShellLinkW*)Unsafe.AsPointer(ref this), pszPathRel, dwReserved).ThrowOnFailure();
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT Resolve(IShellLinkW* pThis, winmdroot.Foundation.HWND hwnd, uint fFlags)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.Resolve(hwnd, fFlags);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Attempts to find the target of a Shell link, even if it has been moved or renamed. (Unicode)</summary>
			/// <param name="hwnd">
			/// <para>Type: <b>HWND</b> A handle to the window that the Shell will use as the parent for a dialog box. The Shell displays the dialog box if it needs to prompt the user for more information while resolving a Shell link.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-resolve#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <param name="fFlags">Type: <b>DWORD</b></param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>
			/// <para>Following link creation, the name or location of the target may change. The <b>IShellLink::Resolve</b> method first retrieves the path associated with the link. If the object is no longer there or has been renamed, <b>Resolve</b> will attempt to find it. If successful, and the following conditions are met, the file that the link object was loaded from will be updated to reflect the new state of the link object. </para>
			/// <para>This doc was truncated.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-resolve#">Read more on docs.microsoft.com</see>.</para>
			/// </remarks>
			public void Resolve(winmdroot.Foundation.HWND hwnd, uint fFlags)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.HWND ,uint ,winmdroot.Foundation.HRESULT>)lpVtbl[19])((IShellLinkW*)Unsafe.AsPointer(ref this), hwnd, fFlags).ThrowOnFailure();
			}

			/// <inheritdoc cref="SetPath(winmdroot.Foundation.PCWSTR)"/>
			internal unsafe void SetPath(string pszFile)
			{
				fixed (char* pszFileLocal = pszFile)
				{
					this.SetPath(pszFileLocal);
				}
			}

			[UnmanagedCallersOnly(CallConvs = new []{
typeof(CallConvStdcall)}
)]
			private static winmdroot.Foundation.HRESULT SetPath(IShellLinkW* pThis, winmdroot.Foundation.PCWSTR pszFile)
			{
				try
				{
					winmdroot.Foundation.HRESULT __hr = ComHelpers.UnwrapCCW(pThis, out Interface __object);
					if (__hr.Failed)
					{
						return __hr;
					}
					return __object.SetPath(pszFile);
				}
				catch (Exception ex)
				{
					return (winmdroot.Foundation.HRESULT)ex.HResult;
				}
			}

			/// <summary>Sets the path and file name for the target of a Shell link object. (Unicode)</summary>
			/// <param name="pszFile">
			/// <para>Type: <b>LPCTSTR</b> The address of a buffer that contains the new path.</para>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setpath#parameters">Read more on docs.microsoft.com</see>.</para>
			/// </param>
			/// <returns>
			/// <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
			/// </returns>
			/// <remarks>
			/// <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishelllinkw-setpath">Learn more about this API from docs.microsoft.com</see>.</para>
			/// </remarks>
			public void SetPath(winmdroot.Foundation.PCWSTR pszFile)
			{
				((delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT>)lpVtbl[20])((IShellLinkW*)Unsafe.AsPointer(ref this), pszFile).ThrowOnFailure();
			}

			internal struct Vtbl
			{
				internal delegate *unmanaged [Stdcall]<IShellLinkW*,global::System.Guid* ,void** ,winmdroot.Foundation.HRESULT> QueryInterface_1;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,uint> AddRef_2;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,uint> Release_3;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Storage.FileSystem.WIN32_FIND_DATAW* ,uint ,winmdroot.Foundation.HRESULT> GetPath_4;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.Shell.Common.ITEMIDLIST** ,winmdroot.Foundation.HRESULT> GetIDList_5;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.Shell.Common.ITEMIDLIST* ,winmdroot.Foundation.HRESULT> SetIDList_6;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Foundation.HRESULT> GetDescription_7;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT> SetDescription_8;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Foundation.HRESULT> GetWorkingDirectory_9;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT> SetWorkingDirectory_10;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,winmdroot.Foundation.HRESULT> GetArguments_11;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT> SetArguments_12;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,ushort* ,winmdroot.Foundation.HRESULT> GetHotkey_13;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,ushort ,winmdroot.Foundation.HRESULT> SetHotkey_14;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD* ,winmdroot.Foundation.HRESULT> GetShowCmd_15;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD ,winmdroot.Foundation.HRESULT> SetShowCmd_16;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PWSTR ,int ,int* ,winmdroot.Foundation.HRESULT> GetIconLocation_17;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,int ,winmdroot.Foundation.HRESULT> SetIconLocation_18;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,uint ,winmdroot.Foundation.HRESULT> SetRelativePath_19;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.HWND ,uint ,winmdroot.Foundation.HRESULT> Resolve_20;

				internal delegate *unmanaged [Stdcall]<IShellLinkW*,winmdroot.Foundation.PCWSTR ,winmdroot.Foundation.HRESULT> SetPath_21;
			} 
			public static void PopulateVTable(Vtbl* vtable)
			{
				vtable->GetPath_4 = &GetPath;
				vtable->GetIDList_5 = &GetIDList;
				vtable->SetIDList_6 = &SetIDList;
				vtable->GetDescription_7 = &GetDescription;
				vtable->SetDescription_8 = &SetDescription;
				vtable->GetWorkingDirectory_9 = &GetWorkingDirectory;
				vtable->SetWorkingDirectory_10 = &SetWorkingDirectory;
				vtable->GetArguments_11 = &GetArguments;
				vtable->SetArguments_12 = &SetArguments;
				vtable->GetHotkey_13 = &GetHotkey;
				vtable->SetHotkey_14 = &SetHotkey;
				vtable->GetShowCmd_15 = &GetShowCmd;
				vtable->SetShowCmd_16 = &SetShowCmd;
				vtable->GetIconLocation_17 = &GetIconLocation;
				vtable->SetIconLocation_18 = &SetIconLocation;
				vtable->SetRelativePath_19 = &SetRelativePath;
				vtable->Resolve_20 = &Resolve;
				vtable->SetPath_21 = &SetPath;
			}

			private void** lpVtbl;

			/// <summary>The IID guid for this interface.</summary>
			/// <value>{000214f9-0000-0000-c000-000000000046}</value>
			internal static readonly Guid IID_Guid = new Guid(0x000214F9, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

			static ref readonly Guid IComIID.Guid			{
								[MethodImpl(MethodImplOptions.AggressiveInlining)]
get
				{
					ReadOnlySpan<byte> data = new byte[]					{
0xF9,0x14,0x02,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46					};
					return ref Unsafe.As<byte,Guid>(ref MemoryMarshal.GetReference(data));
				}
			}
			[Guid("000214F9-0000-0000-C000-000000000046"),InterfaceType(ComInterfaceType.InterfaceIsIUnknown),ComImport()]
			[SupportedOSPlatform("windows5.1.2600")]
			internal interface Interface
			{
				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT GetPath(winmdroot.Foundation.PWSTR pszFile, int cch, winmdroot.Storage.FileSystem.WIN32_FIND_DATAW* pfd, uint fFlags);

				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT GetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST** ppidl);

				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT SetIDList(winmdroot.UI.Shell.Common.ITEMIDLIST* pidl);

								[PreserveSig()]
winmdroot.Foundation.HRESULT GetDescription(winmdroot.Foundation.PWSTR pszName, int cch);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetDescription(winmdroot.Foundation.PCWSTR pszName);

								[PreserveSig()]
winmdroot.Foundation.HRESULT GetWorkingDirectory(winmdroot.Foundation.PWSTR pszDir, int cch);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetWorkingDirectory(winmdroot.Foundation.PCWSTR pszDir);

								[PreserveSig()]
winmdroot.Foundation.HRESULT GetArguments(winmdroot.Foundation.PWSTR pszArgs, int cch);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetArguments(winmdroot.Foundation.PCWSTR pszArgs);

				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT GetHotkey(ushort* pwHotkey);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetHotkey(ushort wHotkey);

				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT GetShowCmd(winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD* piShowCmd);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetShowCmd(winmdroot.UI.WindowsAndMessaging.SHOW_WINDOW_CMD iShowCmd);

				[PreserveSig()]
				unsafe winmdroot.Foundation.HRESULT GetIconLocation(winmdroot.Foundation.PWSTR pszIconPath, int cch, int* piIcon);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetIconLocation(winmdroot.Foundation.PCWSTR pszIconPath, int iIcon);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetRelativePath(winmdroot.Foundation.PCWSTR pszPathRel, uint dwReserved);

								[PreserveSig()]
winmdroot.Foundation.HRESULT Resolve(winmdroot.Foundation.HWND hwnd, uint fFlags);

								[PreserveSig()]
winmdroot.Foundation.HRESULT SetPath(winmdroot.Foundation.PCWSTR pszFile);
			}
		}

		[Guid("00021401-0000-0000-C000-000000000046"),ComImport()]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal partial class ShellLink
		{
		}

		[Flags]
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
		internal enum SLGP_FLAGS
		{
			SLGP_SHORTPATH = 0x00000001,
			SLGP_UNCPRIORITY = 0x00000002,
			SLGP_RAWPATH = 0x00000004,
			SLGP_RELATIVEPRIORITY = 0x00000008,
		}
	}
}
